<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Envision: Model::Model Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Envision
   </div>
   <div id="projectbrief">A visual programming IDE for object-oriented languages</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceModel.html">Model</a></li><li class="navelem"><a class="el" href="classModel_1_1Model.html">Model</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classModel_1_1Model-members.html">List of all members</a> &#124;
<a href="#signals">Signals</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">Model::Model Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classModel_1_1Model.html" title="The Model class is a management and access entity for a program tree.">Model</a> class is a management and access entity for a program tree.  
 <a href="classModel_1_1Model.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for Model::Model:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classModel_1_1Model.png" usemap="#Model::Model_map" alt=""/>
  <map id="Model::Model_map" name="Model::Model_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="signals"></a>
Signals</h2></td></tr>
<tr class="memitem:a5329fab71cdf6e29cddd86e1b7aea92c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#a5329fab71cdf6e29cddd86e1b7aea92c">nameModified</a> (<a class="el" href="classModel_1_1Node.html">Node</a> *node, const QString &amp;oldName)</td></tr>
<tr class="memdesc:a5329fab71cdf6e29cddd86e1b7aea92c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emitted when the name of a node has changed.  <a href="#a5329fab71cdf6e29cddd86e1b7aea92c">More...</a><br/></td></tr>
<tr class="separator:a5329fab71cdf6e29cddd86e1b7aea92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda34299075a74dcd682c58fdfa102b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#afda34299075a74dcd682c58fdfa102b7">nodeFullyLoaded</a> (<a class="el" href="classModel_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:afda34299075a74dcd682c58fdfa102b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emitted when a partially loaded node becomes fully loaded.  <a href="#afda34299075a74dcd682c58fdfa102b7">More...</a><br/></td></tr>
<tr class="separator:afda34299075a74dcd682c58fdfa102b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba60aa7bdc3ce8fbaa06354cdb093512"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#aba60aa7bdc3ce8fbaa06354cdb093512">nodePartiallyLoaded</a> (<a class="el" href="classModel_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:aba60aa7bdc3ce8fbaa06354cdb093512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emitted when a fully loaded node becomes partially loaded.  <a href="#aba60aa7bdc3ce8fbaa06354cdb093512">More...</a><br/></td></tr>
<tr class="separator:aba60aa7bdc3ce8fbaa06354cdb093512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b4ca9e2d91278c42df4fecca3bb6c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#a60b4ca9e2d91278c42df4fecca3bb6c3">nodesModified</a> (QList&lt; <a class="el" href="classModel_1_1Node.html">Node</a> * &gt; nodes)</td></tr>
<tr class="memdesc:a60b4ca9e2d91278c42df4fecca3bb6c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emitted at the end of a modification block.  <a href="#a60b4ca9e2d91278c42df4fecca3bb6c3">More...</a><br/></td></tr>
<tr class="separator:a60b4ca9e2d91278c42df4fecca3bb6c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0247247374ae7d04ddfd5aba38ea14fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#a0247247374ae7d04ddfd5aba38ea14fd">rootNodeSet</a> (<a class="el" href="classModel_1_1Node.html">Node</a> *<a class="el" href="classModel_1_1Model.html#a0662c68a4b6d31308adf744e713b18ba">root</a>)</td></tr>
<tr class="memdesc:a0247247374ae7d04ddfd5aba38ea14fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emitted when a new root node was set.  <a href="#a0247247374ae7d04ddfd5aba38ea14fd">More...</a><br/></td></tr>
<tr class="separator:a0247247374ae7d04ddfd5aba38ea14fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a13688b2534d6785b2b69ff5b3c8c733d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#a13688b2534d6785b2b69ff5b3c8c733d">Model</a> (<a class="el" href="classModel_1_1Node.html">Node</a> *<a class="el" href="classModel_1_1Model.html#a0662c68a4b6d31308adf744e713b18ba">root</a>=nullptr)</td></tr>
<tr class="memdesc:a13688b2534d6785b2b69ff5b3c8c733d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new <a class="el" href="classModel_1_1Model.html" title="The Model class is a management and access entity for a program tree.">Model</a> with the given <em>root</em>.  <a href="#a13688b2534d6785b2b69ff5b3c8c733d">More...</a><br/></td></tr>
<tr class="separator:a13688b2534d6785b2b69ff5b3c8c733d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af014909ae9be6446a3108d7deb6f29e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#af014909ae9be6446a3108d7deb6f29e3">Model</a> (const QString &amp;<a class="el" href="classModel_1_1Model.html#ac3a70dce69b4d62cd902158aa7be56d0">name</a>, <a class="el" href="classModel_1_1Node.html">Node</a> *<a class="el" href="classModel_1_1Model.html#a0662c68a4b6d31308adf744e713b18ba">root</a>=nullptr)</td></tr>
<tr class="memdesc:af014909ae9be6446a3108d7deb6f29e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new <a class="el" href="classModel_1_1Model.html" title="The Model class is a management and access entity for a program tree.">Model</a> with the given <em>name</em> and <em>root</em>.  <a href="#af014909ae9be6446a3108d7deb6f29e3">More...</a><br/></td></tr>
<tr class="separator:af014909ae9be6446a3108d7deb6f29e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74461078f3733d0676895b93903dcbc2"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#a74461078f3733d0676895b93903dcbc2">~Model</a> ()</td></tr>
<tr class="memdesc:a74461078f3733d0676895b93903dcbc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the root node corresponding to the <a class="el" href="classModel_1_1Model.html" title="The Model class is a management and access entity for a program tree.">Model</a>.  <a href="#a74461078f3733d0676895b93903dcbc2">More...</a><br/></td></tr>
<tr class="separator:a74461078f3733d0676895b93903dcbc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482b91fb73134c2860154e924816c344"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#a482b91fb73134c2860154e924816c344">addUnresolvedReference</a> (<a class="el" href="classModel_1_1Reference.html">Reference</a> *ref)</td></tr>
<tr class="memdesc:a482b91fb73134c2860154e924816c344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the specified reference to the unresolved references list.  <a href="#a482b91fb73134c2860154e924816c344">More...</a><br/></td></tr>
<tr class="separator:a482b91fb73134c2860154e924816c344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1eff88fb639e3b79144268858b029e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#aa1eff88fb639e3b79144268858b029e1">beginExclusiveRead</a> ()</td></tr>
<tr class="memdesc:aa1eff88fb639e3b79144268858b029e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins an exclusive read.  <a href="#aa1eff88fb639e3b79144268858b029e1">More...</a><br/></td></tr>
<tr class="separator:aa1eff88fb639e3b79144268858b029e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb529525d3f1a3b95f9abfec9aa7487d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#aeb529525d3f1a3b95f9abfec9aa7487d">beginModification</a> (<a class="el" href="classModel_1_1Node.html">Node</a> *<a class="el" href="classModel_1_1Model.html#a5de2d8419f73daac676a9bf8a3c8c429">modificationTarget</a>, const QString &amp;text=QString())</td></tr>
<tr class="memdesc:aeb529525d3f1a3b95f9abfec9aa7487d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins a modification session.  <a href="#aeb529525d3f1a3b95f9abfec9aa7487d">More...</a><br/></td></tr>
<tr class="separator:aeb529525d3f1a3b95f9abfec9aa7487d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575271a40618cb2514f20b0c1d77f928"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#a575271a40618cb2514f20b0c1d77f928">canBeModified</a> (const <a class="el" href="classModel_1_1Node.html">Node</a> *node) const </td></tr>
<tr class="memdesc:a575271a40618cb2514f20b0c1d77f928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a node can be modified.  <a href="#a575271a40618cb2514f20b0c1d77f928">More...</a><br/></td></tr>
<tr class="separator:a575271a40618cb2514f20b0c1d77f928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb33b41df74f8016e25b03237c2bb810"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#abb33b41df74f8016e25b03237c2bb810">changeModificationTarget</a> (<a class="el" href="classModel_1_1Node.html">Node</a> *<a class="el" href="classModel_1_1Model.html#a5de2d8419f73daac676a9bf8a3c8c429">modificationTarget</a>)</td></tr>
<tr class="memdesc:abb33b41df74f8016e25b03237c2bb810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the modification target and possibly the access unit that the current writer is allowed to access.  <a href="#abb33b41df74f8016e25b03237c2bb810">More...</a><br/></td></tr>
<tr class="separator:abb33b41df74f8016e25b03237c2bb810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86c3b873c283aca746ce70e710a9860"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#ad86c3b873c283aca746ce70e710a9860">emitNameModified</a> (<a class="el" href="classModel_1_1Node.html">Node</a> *node, const QString &amp;oldName)</td></tr>
<tr class="memdesc:ad86c3b873c283aca746ce70e710a9860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes a nameModified signal to be emitted.  <a href="#ad86c3b873c283aca746ce70e710a9860">More...</a><br/></td></tr>
<tr class="separator:ad86c3b873c283aca746ce70e710a9860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7fb509f5d8cde2727f321d4dbb5351d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#ae7fb509f5d8cde2727f321d4dbb5351d">emitNodeFullyLoaded</a> (<a class="el" href="classModel_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:ae7fb509f5d8cde2727f321d4dbb5351d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes a nodeFullyLoaded signal to be emitted.  <a href="#ae7fb509f5d8cde2727f321d4dbb5351d">More...</a><br/></td></tr>
<tr class="separator:ae7fb509f5d8cde2727f321d4dbb5351d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a151d9bc1d145661d78cdc9d721b27a93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#a151d9bc1d145661d78cdc9d721b27a93">emitNodePartiallyLoaded</a> (<a class="el" href="classModel_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:a151d9bc1d145661d78cdc9d721b27a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes a nodePartiallyLoaded signal to be emitted.  <a href="#a151d9bc1d145661d78cdc9d721b27a93">More...</a><br/></td></tr>
<tr class="separator:a151d9bc1d145661d78cdc9d721b27a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92daf1b73d281f3a33967aa2e3d61add"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#a92daf1b73d281f3a33967aa2e3d61add">endExclusiveRead</a> ()</td></tr>
<tr class="memdesc:a92daf1b73d281f3a33967aa2e3d61add"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends an exclusive read.  <a href="#a92daf1b73d281f3a33967aa2e3d61add">More...</a><br/></td></tr>
<tr class="separator:a92daf1b73d281f3a33967aa2e3d61add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a995413407a52a23bea27ec69266e8074"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#a995413407a52a23bea27ec69266e8074">endModification</a> ()</td></tr>
<tr class="memdesc:a995413407a52a23bea27ec69266e8074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends a modification session.  <a href="#a995413407a52a23bea27ec69266e8074">More...</a><br/></td></tr>
<tr class="separator:a995413407a52a23bea27ec69266e8074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52415153241ce9e37c4e8e8952e7fe00"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#a52415153241ce9e37c4e8e8952e7fe00">isBeingModified</a> () const </td></tr>
<tr class="separator:a52415153241ce9e37c4e8e8952e7fe00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad904287736156584888539103b8d89de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#ad904287736156584888539103b8d89de">isOwnedByUndoStack</a> (const <a class="el" href="classModel_1_1Node.html">Node</a> *node, const <a class="el" href="classModel_1_1NodeOwningCommand.html">NodeOwningCommand</a> *excludeCommand) const </td></tr>
<tr class="memdesc:ad904287736156584888539103b8d89de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether <em>node</em> is owned by a command in the undo stack.  <a href="#ad904287736156584888539103b8d89de">More...</a><br/></td></tr>
<tr class="separator:ad904287736156584888539103b8d89de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22bdbda92fbca40d55e3bfba4dfc64d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#a22bdbda92fbca40d55e3bfba4dfc64d7">load</a> (<a class="el" href="classModel_1_1PersistentStore.html">PersistentStore</a> *<a class="el" href="classModel_1_1Model.html#a3681a66d0ee5731c1f5e9f7135c2bfbb">store</a>, const QString &amp;<a class="el" href="classModel_1_1Model.html#ac3a70dce69b4d62cd902158aa7be56d0">name</a>)</td></tr>
<tr class="memdesc:a22bdbda92fbca40d55e3bfba4dfc64d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the current model tree from the specified persistent store.  <a href="#a22bdbda92fbca40d55e3bfba4dfc64d7">More...</a><br/></td></tr>
<tr class="separator:a22bdbda92fbca40d55e3bfba4dfc64d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc04869ab84d5924623c87618809657d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModel_1_1ModelManager.html">ModelManager</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#acc04869ab84d5924623c87618809657d">manager</a> () const </td></tr>
<tr class="separator:acc04869ab84d5924623c87618809657d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de2d8419f73daac676a9bf8a3c8c429"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#a5de2d8419f73daac676a9bf8a3c8c429">modificationTarget</a> () const </td></tr>
<tr class="separator:a5de2d8419f73daac676a9bf8a3c8c429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a70dce69b4d62cd902158aa7be56d0"><td class="memItemLeft" align="right" valign="top">QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#ac3a70dce69b4d62cd902158aa7be56d0">name</a> ()</td></tr>
<tr class="memdesc:ac3a70dce69b4d62cd902158aa7be56d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the model.  <a href="#ac3a70dce69b4d62cd902158aa7be56d0">More...</a><br/></td></tr>
<tr class="separator:ac3a70dce69b4d62cd902158aa7be56d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417d70c35fc6faaaf197076822e144ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#a417d70c35fc6faaaf197076822e144ce">pushCommandOnUndoStack</a> (<a class="el" href="classModel_1_1UndoCommand.html">UndoCommand</a> *command)</td></tr>
<tr class="memdesc:a417d70c35fc6faaaf197076822e144ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes the specified command on the undo stack and executes it.  <a href="#a417d70c35fc6faaaf197076822e144ce">More...</a><br/></td></tr>
<tr class="separator:a417d70c35fc6faaaf197076822e144ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9fc71567c8d9aa643dcd21b8770b5cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#ab9fc71567c8d9aa643dcd21b8770b5cb">redo</a> ()</td></tr>
<tr class="memdesc:ab9fc71567c8d9aa643dcd21b8770b5cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redoes the commands executed in the next modification block.  <a href="#ab9fc71567c8d9aa643dcd21b8770b5cb">More...</a><br/></td></tr>
<tr class="separator:ab9fc71567c8d9aa643dcd21b8770b5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394b4a5b8874f17b25cea87bd5a26307"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#a394b4a5b8874f17b25cea87bd5a26307">removeUnresolvedReference</a> (<a class="el" href="classModel_1_1Reference.html">Reference</a> *ref)</td></tr>
<tr class="memdesc:a394b4a5b8874f17b25cea87bd5a26307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the specified reference to the unresolved references list.  <a href="#a394b4a5b8874f17b25cea87bd5a26307">More...</a><br/></td></tr>
<tr class="separator:a394b4a5b8874f17b25cea87bd5a26307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0662c68a4b6d31308adf744e713b18ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#a0662c68a4b6d31308adf744e713b18ba">root</a> ()</td></tr>
<tr class="memdesc:a0662c68a4b6d31308adf744e713b18ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the root node for this model.  <a href="#a0662c68a4b6d31308adf744e713b18ba">More...</a><br/></td></tr>
<tr class="separator:a0662c68a4b6d31308adf744e713b18ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb5b76be3f68509d1db8ac6c358e22ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModel_1_1NodeReadWriteLock.html">NodeReadWriteLock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#adb5b76be3f68509d1db8ac6c358e22ce">rootLock</a> ()</td></tr>
<tr class="memdesc:adb5b76be3f68509d1db8ac6c358e22ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lock corresponding to the top-most (root) access unit.  <a href="#adb5b76be3f68509d1db8ac6c358e22ce">More...</a><br/></td></tr>
<tr class="separator:adb5b76be3f68509d1db8ac6c358e22ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87743bd99055166e9873b1719bba50a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#ad87743bd99055166e9873b1719bba50a">save</a> (<a class="el" href="classModel_1_1PersistentStore.html">PersistentStore</a> *<a class="el" href="classModel_1_1Model.html#a3681a66d0ee5731c1f5e9f7135c2bfbb">store</a>=nullptr)</td></tr>
<tr class="memdesc:ad87743bd99055166e9873b1719bba50a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the model tree in persistent store of the model.  <a href="#ad87743bd99055166e9873b1719bba50a">More...</a><br/></td></tr>
<tr class="separator:ad87743bd99055166e9873b1719bba50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e838cb13a9afc693fe69dfa409c336c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#a7e838cb13a9afc693fe69dfa409c336c">setName</a> (const QString &amp;<a class="el" href="classModel_1_1Model.html#ac3a70dce69b4d62cd902158aa7be56d0">name</a>)</td></tr>
<tr class="memdesc:a7e838cb13a9afc693fe69dfa409c336c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the name of the model.  <a href="#a7e838cb13a9afc693fe69dfa409c336c">More...</a><br/></td></tr>
<tr class="separator:a7e838cb13a9afc693fe69dfa409c336c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81613790da1f3ea05f55239d8a3738a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#a81613790da1f3ea05f55239d8a3738a2">setRoot</a> (<a class="el" href="classModel_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:a81613790da1f3ea05f55239d8a3738a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the root node of this model to <em>node</em>.  <a href="#a81613790da1f3ea05f55239d8a3738a2">More...</a><br/></td></tr>
<tr class="separator:a81613790da1f3ea05f55239d8a3738a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3681a66d0ee5731c1f5e9f7135c2bfbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModel_1_1PersistentStore.html">PersistentStore</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#a3681a66d0ee5731c1f5e9f7135c2bfbb">store</a> ()</td></tr>
<tr class="memdesc:a3681a66d0ee5731c1f5e9f7135c2bfbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current store for this model.  <a href="#a3681a66d0ee5731c1f5e9f7135c2bfbb">More...</a><br/></td></tr>
<tr class="separator:a3681a66d0ee5731c1f5e9f7135c2bfbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac073ff3d27e22425881e976425d6709d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#ac073ff3d27e22425881e976425d6709d">tryResolvingReferences</a> ()</td></tr>
<tr class="memdesc:ac073ff3d27e22425881e976425d6709d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to resolve all unresolved references.  <a href="#ac073ff3d27e22425881e976425d6709d">More...</a><br/></td></tr>
<tr class="separator:ac073ff3d27e22425881e976425d6709d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af858da7a498955c10641f3e81014635b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#af858da7a498955c10641f3e81014635b">undo</a> ()</td></tr>
<tr class="memdesc:af858da7a498955c10641f3e81014635b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undoes the commands executed in the previous modification block.  <a href="#af858da7a498955c10641f3e81014635b">More...</a><br/></td></tr>
<tr class="separator:af858da7a498955c10641f3e81014635b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40fce2a00530aeed64cfe9251d218230"><td class="memItemLeft" align="right" valign="top">const QList&lt; <a class="el" href="classModel_1_1Reference.html">Reference</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#a40fce2a00530aeed64cfe9251d218230">unresolvedReferences</a> () const </td></tr>
<tr class="memdesc:a40fce2a00530aeed64cfe9251d218230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of all loaded unresolved references in the model.  <a href="#a40fce2a00530aeed64cfe9251d218230">More...</a><br/></td></tr>
<tr class="separator:a40fce2a00530aeed64cfe9251d218230"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a36c5f3049c6994f472fc8d59571bff02"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#a36c5f3049c6994f472fc8d59571bff02">isOwnedByCommand</a> (const <a class="el" href="classModel_1_1Node.html">Node</a> *node, const <a class="el" href="classModel_1_1UndoCommand.html">UndoCommand</a> *cmd, const <a class="el" href="classModel_1_1NodeOwningCommand.html">NodeOwningCommand</a> *excludeCommand)</td></tr>
<tr class="memdesc:a36c5f3049c6994f472fc8d59571bff02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether <em>node</em> is transitively owned by <em>cmd</em>.  <a href="#a36c5f3049c6994f472fc8d59571bff02">More...</a><br/></td></tr>
<tr class="separator:a36c5f3049c6994f472fc8d59571bff02"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ac06e20eeee43092beea90b57af732a97"><td class="memItemLeft" align="right" valign="top">QUndoStack&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#ac06e20eeee43092beea90b57af732a97">commands</a></td></tr>
<tr class="memdesc:ac06e20eeee43092beea90b57af732a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">The command stack that holds the undo history.  <a href="#ac06e20eeee43092beea90b57af732a97">More...</a><br/></td></tr>
<tr class="separator:ac06e20eeee43092beea90b57af732a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2537d9534d42fa876089c601b809b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModel_1_1NodeReadWriteLock.html">NodeReadWriteLock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#a7f2537d9534d42fa876089c601b809b9">currentModificationLock</a> {}</td></tr>
<tr class="memdesc:a7f2537d9534d42fa876089c601b809b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lock of the access unit that is responsible for the current modification target node.  <a href="#a7f2537d9534d42fa876089c601b809b9">More...</a><br/></td></tr>
<tr class="separator:a7f2537d9534d42fa876089c601b809b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9ccf2a9ed7591c5a0728512506ace8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#a2a9ccf2a9ed7591c5a0728512506ace8">currentModificationTarget</a> {}</td></tr>
<tr class="memdesc:a2a9ccf2a9ed7591c5a0728512506ace8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The node that is the top-most ancestor of all other nodes that are currently being modification.  <a href="#a2a9ccf2a9ed7591c5a0728512506ace8">More...</a><br/></td></tr>
<tr class="separator:a2a9ccf2a9ed7591c5a0728512506ace8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ae87570c8d651c9c409d85c00925be"><td class="memItemLeft" align="right" valign="top">QReadWriteLock&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#ac7ae87570c8d651c9c409d85c00925be">exclusiveAccess</a></td></tr>
<tr class="memdesc:ac7ae87570c8d651c9c409d85c00925be"><td class="mdescLeft">&#160;</td><td class="mdescRight">A ReadWrite lock used for exclusive writer or reader access.  <a href="#ac7ae87570c8d651c9c409d85c00925be">More...</a><br/></td></tr>
<tr class="separator:ac7ae87570c8d651c9c409d85c00925be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559bedefff94e91981fce6cbe2efbb13"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#a559bedefff94e91981fce6cbe2efbb13">modificationInProgress</a> {}</td></tr>
<tr class="memdesc:a559bedefff94e91981fce6cbe2efbb13"><td class="mdescLeft">&#160;</td><td class="mdescRight">This flag indicates if a modification is currently in progress.  <a href="#a559bedefff94e91981fce6cbe2efbb13">More...</a><br/></td></tr>
<tr class="separator:a559bedefff94e91981fce6cbe2efbb13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8398579927ddedec02ed9a251a1f8442"><td class="memItemLeft" align="right" valign="top">QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#a8398579927ddedec02ed9a251a1f8442">modificationText</a></td></tr>
<tr class="memdesc:a8398579927ddedec02ed9a251a1f8442"><td class="mdescLeft">&#160;</td><td class="mdescRight">The test message associated with the current modification operation.  <a href="#a8398579927ddedec02ed9a251a1f8442">More...</a><br/></td></tr>
<tr class="separator:a8398579927ddedec02ed9a251a1f8442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc84d45ce8176dc9e614c5ad779bd00b"><td class="memItemLeft" align="right" valign="top">QList&lt; <a class="el" href="classModel_1_1Node.html">Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#acc84d45ce8176dc9e614c5ad779bd00b">modifiedTargets</a></td></tr>
<tr class="memdesc:acc84d45ce8176dc9e614c5ad779bd00b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of all top-level nodes which were modified as part of the last modification operation.  <a href="#acc84d45ce8176dc9e614c5ad779bd00b">More...</a><br/></td></tr>
<tr class="separator:acc84d45ce8176dc9e614c5ad779bd00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8280fc98d4e4a7153f462f5e5dbbbd50"><td class="memItemLeft" align="right" valign="top">QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#a8280fc98d4e4a7153f462f5e5dbbbd50">name_</a></td></tr>
<tr class="memdesc:a8280fc98d4e4a7153f462f5e5dbbbd50"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of this model.  <a href="#a8280fc98d4e4a7153f462f5e5dbbbd50">More...</a><br/></td></tr>
<tr class="separator:a8280fc98d4e4a7153f462f5e5dbbbd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617d04440d94eff2dd176889ffa66cea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#a617d04440d94eff2dd176889ffa66cea">performedUndoRedo</a> {}</td></tr>
<tr class="memdesc:a617d04440d94eff2dd176889ffa66cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if <a class="el" href="classModel_1_1Model.html#af858da7a498955c10641f3e81014635b" title="Undoes the commands executed in the previous modification block.">undo()</a> or <a class="el" href="classModel_1_1Model.html#ab9fc71567c8d9aa643dcd21b8770b5cb" title="Redoes the commands executed in the next modification block.">redo()</a> were called during the last modification operation.  <a href="#a617d04440d94eff2dd176889ffa66cea">More...</a><br/></td></tr>
<tr class="separator:a617d04440d94eff2dd176889ffa66cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed826416bf2969f75a37feef878ed0e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#aed826416bf2969f75a37feef878ed0e7">pushedNewCommandsOnTheStack</a> {}</td></tr>
<tr class="memdesc:aed826416bf2969f75a37feef878ed0e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if the last modification operation pushed commands on stack.  <a href="#aed826416bf2969f75a37feef878ed0e7">More...</a><br/></td></tr>
<tr class="separator:aed826416bf2969f75a37feef878ed0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9226d3e70cf22c22a8795e78e6ba61f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#a9226d3e70cf22c22a8795e78e6ba61f7">root_</a> {}</td></tr>
<tr class="memdesc:a9226d3e70cf22c22a8795e78e6ba61f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The root node for this model.  <a href="#a9226d3e70cf22c22a8795e78e6ba61f7">More...</a><br/></td></tr>
<tr class="separator:a9226d3e70cf22c22a8795e78e6ba61f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c92b6cfe290457356b07d2d3b90cb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModel_1_1NodeReadWriteLock.html">NodeReadWriteLock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#a37c92b6cfe290457356b07d2d3b90cb2">rootLock_</a></td></tr>
<tr class="memdesc:a37c92b6cfe290457356b07d2d3b90cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lock corresponding to the root access unit.  <a href="#a37c92b6cfe290457356b07d2d3b90cb2">More...</a><br/></td></tr>
<tr class="separator:a37c92b6cfe290457356b07d2d3b90cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605602e34387bc4f504ac89403d34b29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModel_1_1PersistentStore.html">PersistentStore</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#a605602e34387bc4f504ac89403d34b29">store_</a> {}</td></tr>
<tr class="memdesc:a605602e34387bc4f504ac89403d34b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">The persistent store where the model is currently stored.  <a href="#a605602e34387bc4f504ac89403d34b29">More...</a><br/></td></tr>
<tr class="separator:a605602e34387bc4f504ac89403d34b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af75f55ea27f7887f4683da678a425d65"><td class="memItemLeft" align="right" valign="top">QList&lt; <a class="el" href="classModel_1_1Reference.html">Reference</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Model.html#af75f55ea27f7887f4683da678a425d65">unresolvedReferences_</a></td></tr>
<tr class="memdesc:af75f55ea27f7887f4683da678a425d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of all unresolved references which are currently loaded nodes.  <a href="#af75f55ea27f7887f4683da678a425d65">More...</a><br/></td></tr>
<tr class="separator:af75f55ea27f7887f4683da678a425d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classModel_1_1Model.html" title="The Model class is a management and access entity for a program tree.">Model</a> class is a management and access entity for a program tree. </p>
<p>Each program or project in Envision is represented as a tree of nodes called a program model. To manage this tree each project has an associated <a class="el" href="classModel_1_1Model.html" title="The Model class is a management and access entity for a program tree.">Model</a> object.</p>
<p>The life cycle of a project begins with the creation of a new <a class="el" href="classModel_1_1Model.html" title="The Model class is a management and access entity for a program tree.">Model</a> object. This object can then be populated with program nodes by loading an existing tree from a persistent store or by creating a new tree structure.</p>
<p>Further access and operations on the tree are performed through the <a class="el" href="classModel_1_1Model.html" title="The Model class is a management and access entity for a program tree.">Model</a> object. Here is a list of the functionality of a <a class="el" href="classModel_1_1Model.html" title="The Model class is a management and access entity for a program tree.">Model</a>:</p>
<ul>
<li>Root node creation</li>
<li>Saving/loading a model to/from a persistent store</li>
</ul>
<p>Access control to nodes in a concurrent setting</p>
<ul>
<li>Undo/redo functionality</li>
<li>Notifications of model change </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a13688b2534d6785b2b69ff5b3c8c733d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Model::Model::Model </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>root</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new <a class="el" href="classModel_1_1Model.html" title="The Model class is a management and access entity for a program tree.">Model</a> with the given <em>root</em>. </p>
<p>The undo history limit is set to 100 operations. </p>

</div>
</div>
<a class="anchor" id="af014909ae9be6446a3108d7deb6f29e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Model::Model::Model </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>root</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new <a class="el" href="classModel_1_1Model.html" title="The Model class is a management and access entity for a program tree.">Model</a> with the given <em>name</em> and <em>root</em>. </p>
<p>The undo history limit is set to 100 operations. </p>

</div>
</div>
<a class="anchor" id="a74461078f3733d0676895b93903dcbc2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Model::Model::~Model </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the root node corresponding to the <a class="el" href="classModel_1_1Model.html" title="The Model class is a management and access entity for a program tree.">Model</a>. </p>
<p>Deleting a node normally causes the corresponding subtree to be deleted. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a482b91fb73134c2860154e924816c344"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Model::Model::addUnresolvedReference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1Reference.html">Reference</a> *&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the specified reference to the unresolved references list. </p>

</div>
</div>
<a class="anchor" id="aa1eff88fb639e3b79144268858b029e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Model::Model::beginExclusiveRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begins an exclusive read. </p>
<p>During an exclusive read, the application model can not be modified by any other thread. Other readers, including exclusive readers will be allowed to access the model.</p>
<p>Call Model::endExclusiveRead() to end the exclusive reading block. </p>

</div>
</div>
<a class="anchor" id="aeb529525d3f1a3b95f9abfec9aa7487d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Model::Model::beginModification </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>modificationTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>text</em> = <code>QString()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begins a modification session. </p>
<p>Before calling a method on a tree node that modifies the node, a writer thread must first begin a modification session. Write access to the underlying tree model must always occure in a modification block. Call Model::beginModification() to begin this block and Model::endModification() to end the block:</p>
<p><a class="el" href="classModel_1_1Model.html" title="The Model class is a management and access entity for a program tree.">Model</a> m; ... Node* someNode; ... m.beginModification(someNode, "modification description"); ... Code that makes modification to the subtree rooted at someNode, and within the access unit corresponding ... to someNode m.endModification(); ... Other exclusive readers or other writers can now be granted access</p>
<p>Only one thread can be in a modification session at a time. Furthermore this thread can only modify nodes which fall within the current access unit.</p>
<p>Each node has a unique access unit associated with it. An access unit is simply identified by a lock. The Node::getAccessLock() method can be used to get the access lock associated with a node. By default this is the lock of the parent node, or if there is no parent node (this is the root node), the lock of the <a class="el" href="classModel_1_1Model.html" title="The Model class is a management and access entity for a program tree.">Model</a>. The user can reimplement the Node::getAccessLock() method to return a new access lock therby defining a new access unit.</p>
<p>If there is a reader that has requested exclusive access via Model::beginExclusiveRead() this method will block until the reader calls Model::endExclusiveRead()</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modificationTarget</td><td>the top-most ancestor node of all nodes that will be modified.</td></tr>
    <tr><td class="paramname">text</td><td>the text that will be associated with this modification and put on the undo stack. This parameter has no effect if this modification is used to call undo/redo and not to execute new commands. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a575271a40618cb2514f20b0c1d77f928"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Model::Model::canBeModified </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a node can be modified. </p>
<p>A node can be modified if the following three conditions are met:</p>
<ul>
<li>The <a class="el" href="classModel_1_1Model.html" title="The Model class is a management and access entity for a program tree.">Model</a> is in a modification session, started with Model::beginModification().</li>
<li>It is, or has as a parent, the current modification target.</li>
<li>It belongs to the same access unit as the current modification target.</li>
</ul>
<p>This method returns true if all conditions are met and false otherwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node to check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abb33b41df74f8016e25b03237c2bb810"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Model::Model::changeModificationTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>modificationTarget</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the modification target and possibly the access unit that the current writer is allowed to access. </p>
<p>This method can be used within a modification block in order to change the current modification target. This will release the access lock of the current target and acquire the lock of the new target.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modificationTarget</td><td>The target that should become the current modification target. The writer thread will be allowed to modify all nodes belonging to the subtree of this target and falling within the same access unit</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classModel_1_1ModelException.html">ModelException</a></td><td>if this method is called without calling Model::beginModification() first. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad86c3b873c283aca746ce70e710a9860"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Model::Model::emitNameModified </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>oldName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Causes a nameModified signal to be emitted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Which node's name has changed </td></tr>
    <tr><td class="paramname">oldNmae</td><td>What was the old name of the node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae7fb509f5d8cde2727f321d4dbb5351d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Model::Model::emitNodeFullyLoaded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Causes a nodeFullyLoaded signal to be emitted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node which is now fully loaded. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a151d9bc1d145661d78cdc9d721b27a93"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Model::Model::emitNodePartiallyLoaded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Causes a nodePartiallyLoaded signal to be emitted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node which is now partially loaded. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a92daf1b73d281f3a33967aa2e3d61add"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Model::Model::endExclusiveRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ends an exclusive read. </p>
<p>This function must always be called after a call to Model::beginExclusiveRead() </p>

</div>
</div>
<a class="anchor" id="a995413407a52a23bea27ec69266e8074"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Model::Model::endModification </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ends a modification session. </p>
<p>This method must always be called after a call Model::beginModification(). It concludes the modification session by releasing all acquired locks and emits the Mode::nodesModified signal to notify listeners about the changes.</p>
<p>This method must be called before the any other thread can gain exclusive access to the tree model. </p>

</div>
</div>
<a class="anchor" id="a52415153241ce9e37c4e8e8952e7fe00"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Model::Model::isBeingModified </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a36c5f3049c6994f472fc8d59571bff02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Model::Model::isOwnedByCommand </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classModel_1_1UndoCommand.html">UndoCommand</a> *&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classModel_1_1NodeOwningCommand.html">NodeOwningCommand</a> *&#160;</td>
          <td class="paramname"><em>excludeCommand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether <em>node</em> is transitively owned by <em>cmd</em>. </p>
<p>If <em>node</em> is only owned by <em>excludeCommand</em> this method returns false. </p>

</div>
</div>
<a class="anchor" id="ad904287736156584888539103b8d89de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Model::Model::isOwnedByUndoStack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classModel_1_1NodeOwningCommand.html">NodeOwningCommand</a> *&#160;</td>
          <td class="paramname"><em>excludeCommand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether <em>node</em> is owned by a command in the undo stack. </p>
<p>If <em>node</em> is only owned by <em>excludeCommand</em> this method returns false. </p>

</div>
</div>
<a class="anchor" id="a22bdbda92fbca40d55e3bfba4dfc64d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Model::Model::load </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1PersistentStore.html">PersistentStore</a> *&#160;</td>
          <td class="paramname"><em>store</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads the current model tree from the specified persistent store. </p>
<p>The provided store will become the current store of the model.</p>
<p>If this model already has a root node, this method does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">store</td><td>The persistent store where the model should be loaded from.</td></tr>
    <tr><td class="paramname">name</td><td>The model name in the persistent store which contains the model tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acc04869ab84d5924623c87618809657d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1ModelManager.html">ModelManager</a> &amp; Model::Model::manager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5de2d8419f73daac676a9bf8a3c8c429"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1Node.html">Node</a> * Model::Model::modificationTarget </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac3a70dce69b4d62cd902158aa7be56d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QString Model::Model::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of the model. </p>
<p>This is the name under which this model can be found in the persistent store. </p>

</div>
</div>
<a class="anchor" id="a5329fab71cdf6e29cddd86e1b7aea92c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Model::Model::nameModified </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>oldName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emitted when the name of a node has changed. </p>
<p>This signal can be used to trigger symbolic reference updates, so that references are kept consistent when the name of a symbol changes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node that has a new name </td></tr>
    <tr><td class="paramname">oldName</td><td>The old name of the node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afda34299075a74dcd682c58fdfa102b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Model::Model::nodeFullyLoaded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emitted when a partially loaded node becomes fully loaded. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node which is now fully loaded. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aba60aa7bdc3ce8fbaa06354cdb093512"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Model::Model::nodePartiallyLoaded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emitted when a fully loaded node becomes partially loaded. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node which is now partially loaded. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a60b4ca9e2d91278c42df4fecca3bb6c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Model::Model::nodesModified </td>
          <td>(</td>
          <td class="paramtype">QList&lt; <a class="el" href="classModel_1_1Node.html">Node</a> * &gt;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emitted at the end of a modification block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodes</td><td>A list of all nodes modified within this block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a417d70c35fc6faaaf197076822e144ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Model::Model::pushCommandOnUndoStack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1UndoCommand.html">UndoCommand</a> *&#160;</td>
          <td class="paramname"><em>command</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pushes the specified command on the undo stack and executes it. </p>
<p>This method can only be called inside a modification block initiated with Model::beginModification(). Furthermore no calls to Model::undo or Model::redo can be made in the current modification block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>The command to add to the stack.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classModel_1_1ModelException.html">ModelException</a></td><td>if called without calling Model::beginModification() first or if calls to Model::undo() or Model::redo() have already been made. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab9fc71567c8d9aa643dcd21b8770b5cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Model::Model::redo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Redoes the commands executed in the next modification block. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classModel_1_1ModelException.html">ModelException</a></td><td>if called without calling Model::beginModification() first or if a call to Model::pushCommandOnUndoStack() has already been made within this modification block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a394b4a5b8874f17b25cea87bd5a26307"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Model::Model::removeUnresolvedReference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1Reference.html">Reference</a> *&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the specified reference to the unresolved references list. </p>
<p>Call this method when a reference has been resolved. </p>

</div>
</div>
<a class="anchor" id="a0662c68a4b6d31308adf744e713b18ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1Node.html">Node</a> * Model::Model::root </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the root node for this model. </p>

</div>
</div>
<a class="anchor" id="adb5b76be3f68509d1db8ac6c358e22ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1NodeReadWriteLock.html">NodeReadWriteLock</a> * Model::Model::rootLock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the lock corresponding to the top-most (root) access unit. </p>

</div>
</div>
<a class="anchor" id="a0247247374ae7d04ddfd5aba38ea14fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Model::Model::rootNodeSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emitted when a new root node was set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>A pointer to the new root node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad87743bd99055166e9873b1719bba50a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Model::Model::save </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1PersistentStore.html">PersistentStore</a> *&#160;</td>
          <td class="paramname"><em>store</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves the model tree in persistent store of the model. </p>
<p>If this model does not have a current store, the store argument must not be NULL. In that case the provided store will become the current store of the model.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">store</td><td>The persistent store where the model should be saved. If this is NULL the current store will be used. The current store is the one from which the model was loaded. If this is not NULL it will be used instead of the current store. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7e838cb13a9afc693fe69dfa409c336c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Model::Model::setName </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the name of the model. </p>
<p>This is the name under which this model will be save in the persistent store. </p>

</div>
</div>
<a class="anchor" id="a81613790da1f3ea05f55239d8a3738a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Model::Model::setRoot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the root node of this model to <em>node</em>. </p>
<p>The model should not have a root node set. This method must be called outside of a modification block. This action can not be undone. </p>

</div>
</div>
<a class="anchor" id="a3681a66d0ee5731c1f5e9f7135c2bfbb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1PersistentStore.html">PersistentStore</a> * Model::Model::store </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current store for this model. </p>
<p>The current store is the store used to load the model. If this model was created rather than loaded and has not been saved to a persistent store yet this method will return NULL. </p>

</div>
</div>
<a class="anchor" id="ac073ff3d27e22425881e976425d6709d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Model::Model::tryResolvingReferences </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to resolve all unresolved references. </p>
<p>This method must be called within a modification session. </p>

</div>
</div>
<a class="anchor" id="af858da7a498955c10641f3e81014635b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Model::Model::undo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undoes the commands executed in the previous modification block. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classModel_1_1ModelException.html">ModelException</a></td><td>if called without calling Model::beginModification() first or if a call to Model::pushCommandOnUndoStack() has already been made within this modification block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a40fce2a00530aeed64cfe9251d218230"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const QList&lt; <a class="el" href="classModel_1_1Reference.html">Reference</a> * &gt; &amp; Model::Model::unresolvedReferences </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a list of all loaded unresolved references in the model. </p>
<p>Unresolved references which are persisted but not loaded are will not be in the returned list. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ac06e20eeee43092beea90b57af732a97"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QUndoStack Model::Model::commands</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The command stack that holds the undo history. </p>

</div>
</div>
<a class="anchor" id="a7f2537d9534d42fa876089c601b809b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1NodeReadWriteLock.html">NodeReadWriteLock</a>* Model::Model::currentModificationLock {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The lock of the access unit that is responsible for the current modification target node. </p>
<p>Each node has exactly one access unit corresponding to it. A writer must acquire this lock before any modification can occur. The currently acquired lock is stored here so that each write operation can be checked to assure that no write occurs outside of the access unit. </p>

</div>
</div>
<a class="anchor" id="a2a9ccf2a9ed7591c5a0728512506ace8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1Node.html">Node</a>* Model::Model::currentModificationTarget {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The node that is the top-most ancestor of all other nodes that are currently being modification. </p>
<p>Only nodes in the same access unit and below this node (including the node itself) may be modified. </p>

</div>
</div>
<a class="anchor" id="ac7ae87570c8d651c9c409d85c00925be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QReadWriteLock Model::Model::exclusiveAccess</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A ReadWrite lock used for exclusive writer or reader access. </p>
<p>Writers always acquire this lock first and then proceed to acquire exactly one other lock corresponding to the access unit they want to write to.</p>
<p>A reader that requires exclusive access (other readers can still read, but writers can not) can also acquire this lock. Typically however readers do not acquire this lock. </p>

</div>
</div>
<a class="anchor" id="a559bedefff94e91981fce6cbe2efbb13"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Model::Model::modificationInProgress {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This flag indicates if a modification is currently in progress. </p>
<p>Commands can be pushed on the undo stack and executed only if this is true. </p>

</div>
</div>
<a class="anchor" id="a8398579927ddedec02ed9a251a1f8442"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QString Model::Model::modificationText</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The test message associated with the current modification operation. </p>
<p>This text is only used to describe the undo operation that is currently performed. </p>

</div>
</div>
<a class="anchor" id="acc84d45ce8176dc9e614c5ad779bd00b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QList&lt;<a class="el" href="classModel_1_1Node.html">Node</a>*&gt; Model::Model::modifiedTargets</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A list of all top-level nodes which were modified as part of the last modification operation. </p>
<p>This is only used to signal to anyone who is interested in monitoring changes. </p>

</div>
</div>
<a class="anchor" id="a8280fc98d4e4a7153f462f5e5dbbbd50"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QString Model::Model::name_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of this model. </p>
<p>This name will be used to save the model in the persistent store. </p>

</div>
</div>
<a class="anchor" id="a617d04440d94eff2dd176889ffa66cea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Model::Model::performedUndoRedo {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates if <a class="el" href="classModel_1_1Model.html#af858da7a498955c10641f3e81014635b" title="Undoes the commands executed in the previous modification block.">undo()</a> or <a class="el" href="classModel_1_1Model.html#ab9fc71567c8d9aa643dcd21b8770b5cb" title="Redoes the commands executed in the next modification block.">redo()</a> were called during the last modification operation. </p>
<p>A modification operation can do two things:</p>
<ul>
<li>Add new commands on the stack</li>
<li>Call undo/redo</li>
</ul>
<p>The two can not be mixed in the same operation and this flag is used to control this. </p>

</div>
</div>
<a class="anchor" id="aed826416bf2969f75a37feef878ed0e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Model::Model::pushedNewCommandsOnTheStack {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates if the last modification operation pushed commands on stack. </p>
<p>A modification operation can do two things:</p>
<ul>
<li>Add new commands on the stack</li>
<li>Call undo/redo</li>
</ul>
<p>The two can not be mixed in the same operation and this flag is used to control this. </p>

</div>
</div>
<a class="anchor" id="a9226d3e70cf22c22a8795e78e6ba61f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1Node.html">Node</a>* Model::Model::root_ {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The root node for this model. </p>

</div>
</div>
<a class="anchor" id="a37c92b6cfe290457356b07d2d3b90cb2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1NodeReadWriteLock.html">NodeReadWriteLock</a> Model::Model::rootLock_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The lock corresponding to the root access unit. </p>
<p>This is used by synchronized readers and by writers to control access to the root unit. </p>

</div>
</div>
<a class="anchor" id="a605602e34387bc4f504ac89403d34b29"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1PersistentStore.html">PersistentStore</a>* Model::Model::store_ {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The persistent store where the model is currently stored. </p>
<p>This is used in calls to <a class="el" href="classModel_1_1Node.html#ab33abbe1a349349d108142e07bb19db5" title="Fully loads a partially loaded node from the specified persistent store.">Node::loadFully</a> when a partially loaded node needs to load its entire contents. It can also be used by other stores when the model needs to be saved to a different location. </p>

</div>
</div>
<a class="anchor" id="af75f55ea27f7887f4683da678a425d65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QList&lt;<a class="el" href="classModel_1_1Reference.html">Reference</a>*&gt; Model::Model::unresolvedReferences_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A list of all unresolved references which are currently loaded nodes. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
