<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Envision: Model::Node Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Envision
   
   </div>
   <div id="projectbrief">A visual programming IDE for object oriented languages</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceModel.html">Model</a>      </li>
      <li class="navelem"><a class="el" href="classModel_1_1Node.html">Node</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">Model::Node Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="Model::Node" -->
<p>The <a class="el" href="classModel_1_1Node.html" title="The Node class is the foundation element in the model tree in Envision.">Node</a> class is the foundation element in the model tree in Envision.  
 <a href="classModel_1_1Node.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for Model::Node:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classModel_1_1Node.png" usemap="#Model::Node_map" alt=""/>
  <map id="Model::Node_map" name="Model::Node_map">
<area href="classModel_1_1Boolean.html" alt="Model::Boolean" shape="rect" coords="178,56,346,80"/>
<area href="classModel_1_1Character.html" alt="Model::Character" shape="rect" coords="178,112,346,136"/>
<area href="classModel_1_1ExtendableNode.html" alt="Model::ExtendableNode" shape="rect" coords="178,168,346,192"/>
<area href="classModel_1_1Float.html" alt="Model::Float" shape="rect" coords="178,224,346,248"/>
<area href="classModel_1_1Integer.html" alt="Model::Integer" shape="rect" coords="178,280,346,304"/>
<area href="classModel_1_1List.html" alt="Model::List" shape="rect" coords="178,336,346,360"/>
<area href="classModel_1_1Reference.html" alt="Model::Reference" shape="rect" coords="178,392,346,416"/>
<area href="classModel_1_1Text.html" alt="Model::Text" shape="rect" coords="178,448,346,472"/>
<area href="classOOModel_1_1StorageSpecifier.html" alt="OOModel::StorageSpecifier" shape="rect" coords="178,504,346,528"/>
<area href="classOOModel_1_1Visibility.html" alt="OOModel::Visibility" shape="rect" coords="178,560,346,584"/>
</map>
 </div></div>

<p><a href="classModel_1_1Node-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#af2ff52f8a834ec055dca6867ba794208">FindSymbolMode</a> { <a class="el" href="classModel_1_1Node.html#af2ff52f8a834ec055dca6867ba794208a442bce153404d787512d1392ba9000fa">SEARCH_UP</a>, 
<a class="el" href="classModel_1_1Node.html#af2ff52f8a834ec055dca6867ba794208ad32cc9e783e89ba6ffb83011a55abe97">SEARCH_DOWN</a>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classModel_1_1Node.html">Node</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a9eedfb121970934710f1f3c67c26f361">NodeConstructor</a> )(<a class="el" href="classModel_1_1Node.html">Node</a> *<a class="el" href="classModel_1_1Node.html#a0027c2328323a4733b3e594958b6998a">parent</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function pointer type is used to register a constructor for nodes.  <a href="#a9eedfb121970934710f1f3c67c26f361"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classModel_1_1Node.html">Node</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a36d456dafe5835b3f28142507f90cd89">NodePersistenceConstructor</a> )(<a class="el" href="classModel_1_1Node.html">Node</a> *<a class="el" href="classModel_1_1Node.html#a0027c2328323a4733b3e594958b6998a">parent</a>, <a class="el" href="classModel_1_1PersistentStore.html">PersistentStore</a> &amp;store, bool partialLoadHint)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function pointer type is used to register the constructor for nodes that are being loaded from a persistent store.  <a href="#a36d456dafe5835b3f28142507f90cd89"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a6026745a457fb0edde390e06c8168391">Node</a> (<a class="el" href="classModel_1_1Node.html">Node</a> *<a class="el" href="classModel_1_1Node.html#a0027c2328323a4733b3e594958b6998a">parent</a>=nullptr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new node with the specified parent.  <a href="#a6026745a457fb0edde390e06c8168391"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#ab93b813886967b6d93a351c75f31b6e5">~Node</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classModel_1_1NodeReadWriteLock.html">NodeReadWriteLock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#aa33e411bb1aa1aabca6d162f66bc481f">accessLock</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lock used to control access to this node.  <a href="#aa33e411bb1aa1aabca6d162f66bc481f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a72c0d0ffbf6398cc48fd6627ddab6cfe">addToRevision</a> (int valueToAdd)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the revision of this node by the specified amount.  <a href="#a72c0d0ffbf6398cc48fd6627ddab6cfe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#ae6c6fa88579de718cfc16e2a5c22e8e3">beginModification</a> (const QString &amp;text=QString())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins a modification session with the current node as a modification target.  <a href="#ae6c6fa88579de718cfc16e2a5c22e8e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual QList&lt; <a class="el" href="classModel_1_1Node.html">Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a94bae646017c4e4cb3214d0ecc26c539">children</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of all child nodes.  <a href="#a94bae646017c4e4cb3214d0ecc26c539"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#acc19699b25363ba3474acf0000da4329">definesSymbol</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this node defines a symbol and false otherwise.  <a href="#acc19699b25363ba3474acf0000da4329"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#ad54d77f21d23364b560deeca22a6347e">endModification</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends a modification session.  <a href="#ad54d77f21d23364b560deeca22a6347e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a9aad10e0ec7b9359f325db5a3c4fbf90">execute</a> (<a class="el" href="classModel_1_1UndoCommand.html">UndoCommand</a> *command)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the specified command and pushes it on the undo stack.  <a href="#a9aad10e0ec7b9359f325db5a3c4fbf90"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual QList&lt; <a class="el" href="classModel_1_1Node.html">Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a79f332d52ca064cf24683b6efe319249">findSymbols</a> (const QRegExp &amp;symbolExp, <a class="el" href="classModel_1_1Node.html">Node</a> *source, <a class="el" href="classModel_1_1Node.html#af2ff52f8a834ec055dca6867ba794208">FindSymbolMode</a> mode, bool exhaustAllScopes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of all nodes which define a symbol with a name matching <em>symbolExp</em> in the scope of this node.  <a href="#a79f332d52ca064cf24683b6efe319249"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QList&lt; <a class="el" href="classModel_1_1Node.html">Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#ae14f15bda5e64f3f6e8fe62b6dde75bb">findSymbols</a> (const QString &amp;symbol, <a class="el" href="classModel_1_1Node.html">Node</a> *source, <a class="el" href="classModel_1_1Node.html#af2ff52f8a834ec055dca6867ba794208">FindSymbolMode</a> mode, bool exhaustAllScopes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This is equivalent to:  <a href="#ae14f15bda5e64f3f6e8fe62b6dde75bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual QList&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a99b6186b6f8f5259dc93ab37be1c1094">hierarchyTypeIds</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of all ids in the type hierarchy of this node (excluding abstract base classes).  <a href="#a99b6186b6f8f5259dc93ab37be1c1094"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a410cafa4e196e8f572d6f24992bfc914">incrementRevision</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the revision of this node by 1.  <a href="#a410cafa4e196e8f572d6f24992bfc914"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a9fdb27f1c721bd3d89c7881dabd7efc9">isAncestorOf</a> (const <a class="el" href="classModel_1_1Node.html">Node</a> *other) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true of this node is an Ancestor of other and false otherwise.  <a href="#a9fdb27f1c721bd3d89c7881dabd7efc9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a6893aad2fa24f8d83cd73fc8106f5ac9">isFullyLoaded</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this node is fully loaded and false if it is only partially loaded.  <a href="#a6893aad2fa24f8d83cd73fc8106f5ac9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a78e99d1b37afb4ca5575d68391cc0455">isModifyable</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true is the this node can be modified or false otherwise.  <a href="#a78e99d1b37afb4ca5575d68391cc0455"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a3acc47bd4c6dcda029cbcc91a12315e1">isNewPersistenceUnit</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this node should be persisted in a new persistence unit.  <a href="#a3acc47bd4c6dcda029cbcc91a12315e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a20246c48b754e0fceeb7c921f2f1f57b">load</a> (<a class="el" href="classModel_1_1PersistentStore.html">PersistentStore</a> &amp;store)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reloads this node from a persistent store.  <a href="#a20246c48b754e0fceeb7c921f2f1f57b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#ab33abbe1a349349d108142e07bb19db5">loadFully</a> (<a class="el" href="classModel_1_1PersistentStore.html">PersistentStore</a> &amp;store)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully loads a partially loaded node from the specified persistent store.  <a href="#ab33abbe1a349349d108142e07bb19db5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#abb715885b1d1e5cb97aec8ab7888334b">lowestCommonAncestor</a> (<a class="el" href="classModel_1_1Node.html">Node</a> *other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lowest common ancestor of this node and other.  <a href="#abb715885b1d1e5cb97aec8ab7888334b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModel_1_1Model.html">Model</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a8eb7d7162522ca5e4000ce4e2c77ab35">model</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the model managing the tree of the current <a class="el" href="classModel_1_1Node.html" title="The Node class is the foundation element in the model tree in Envision.">Node</a>.  <a href="#a8eb7d7162522ca5e4000ce4e2c77ab35"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a0027c2328323a4733b3e594958b6998a">parent</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parent of this <a class="el" href="classModel_1_1Node.html" title="The Node class is the foundation element in the model tree in Envision.">Node</a> or NULL if this is the root.  <a href="#a0027c2328323a4733b3e594958b6998a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a38b8c8cba2f1ec245a6565436b40693b">persistentUnitNode</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the node that defines the persistence unit for this node.  <a href="#a38b8c8cba2f1ec245a6565436b40693b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a3b55a33f4c27fb4bb2e99b09ce3f6e63">replaceChild</a> (<a class="el" href="classModel_1_1Node.html">Node</a> *child, <a class="el" href="classModel_1_1Node.html">Node</a> *replacement, bool releaseOldChild=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the child item <em>child</em> with the item <em>replacement</em> and returns true on success.  <a href="#a3b55a33f4c27fb4bb2e99b09ce3f6e63"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a868e082304e233d32dde632280c99241">revision</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the revision of this node.  <a href="#a868e082304e233d32dde632280c99241"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a78ce4ee82d2c0ed0b211fa29aec22923">root</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the root node of tree where of this node.  <a href="#a78ce4ee82d2c0ed0b211fa29aec22923"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a30d34fac51548633d6748b09f47a3d92">save</a> (<a class="el" href="classModel_1_1PersistentStore.html">PersistentStore</a> &amp;store) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the current node to a persistent store.  <a href="#a30d34fac51548633d6748b09f47a3d92"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a0662a376982b4cce855e731a0d8134a8">setParent</a> (<a class="el" href="classModel_1_1Node.html">Node</a> *<a class="el" href="classModel_1_1Node.html#a0027c2328323a4733b3e594958b6998a">parent</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the parent of this <a class="el" href="classModel_1_1Node.html" title="The Node class is the foundation element in the model tree in Envision.">Node</a>.  <a href="#a0662a376982b4cce855e731a0d8134a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const QString &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#ac0238f80b3ad5960919e56e959fb8b36">symbolName</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the symbol defined by this node.  <a href="#ac0238f80b3ad5960919e56e959fb8b36"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a1dab7cf9f13060ea1d7c72f979844619">typeId</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an integer id of the type of this <a class="el" href="classModel_1_1Node.html" title="The Node class is the foundation element in the model tree in Envision.">Node</a>.  <a href="#a1dab7cf9f13060ea1d7c72f979844619"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const QString &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a032a9d874557533b1c9c5295f6a4b11d">typeName</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the type of this <a class="el" href="classModel_1_1Node.html" title="The Node class is the foundation element in the model tree in Envision.">Node</a>.  <a href="#a032a9d874557533b1c9c5295f6a4b11d"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a0ca79f2a20d8993eea0e86ca6088da7c">createNewNode</a> (const QString &amp;type, <a class="el" href="classModel_1_1Node.html">Node</a> *<a class="el" href="classModel_1_1Node.html#a0027c2328323a4733b3e594958b6998a">parent</a>=nullptr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new node of the specified type.  <a href="#a0ca79f2a20d8993eea0e86ca6088da7c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a12d7cfdf3abf4c1c2bbefc3654678805">createNewNode</a> (const QString &amp;type, <a class="el" href="classModel_1_1Node.html">Node</a> *<a class="el" href="classModel_1_1Node.html#a0027c2328323a4733b3e594958b6998a">parent</a>, <a class="el" href="classModel_1_1PersistentStore.html">PersistentStore</a> &amp;store, bool partialLoadHint)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new node of the specified type by loading it from a persistent store.  <a href="#a12d7cfdf3abf4c1c2bbefc3654678805"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#abce3db1f4cf4cf5192694631148aebcb">isTypeRegistered</a> (const QString &amp;type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there are already registered constructs for a type with the specified name and false otherwise.  <a href="#abce3db1f4cf4cf5192694631148aebcb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a96dd7615292eeba03fe903f623fb1305">registerNodeType</a> (const QString &amp;type, const <a class="el" href="classModel_1_1Node.html#a9eedfb121970934710f1f3c67c26f361">NodeConstructor</a> constructor, const <a class="el" href="classModel_1_1Node.html#a36d456dafe5835b3f28142507f90cd89">NodePersistenceConstructor</a> persistenceconstructor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the constructors of a class derived from <a class="el" href="classModel_1_1Node.html" title="The Node class is the foundation element in the model tree in Envision.">Node</a>.  <a href="#a96dd7615292eeba03fe903f623fb1305"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#ab01db2467f812532d1c3a441eeae22ea">typeIdStatic</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#aedd2b252f73e3ede9117bb92e6dfd516">fullyLoaded</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This flag indicates if the current node is fullyLoaded.  <a href="#aedd2b252f73e3ede9117bb92e6dfd516"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#ad3a6f51536abb137ede5c427725222d3">parent_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a7cec2acbdfb8620d4901ada5600faacd">revision_</a></td></tr>
<tr><td colspan="2"><h2><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static QMap&lt; QString, <br class="typebreak"/>
<a class="el" href="classModel_1_1Node.html#a9eedfb121970934710f1f3c67c26f361">NodeConstructor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a3e997f8eda29ad3b42d8ac9773afb194">nodeConstructorRegister</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static QMap&lt; QString, <br class="typebreak"/>
<a class="el" href="classModel_1_1Node.html#a36d456dafe5835b3f28142507f90cd89">NodePersistenceConstructor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#abc6b7cb926ca500a5ac3102409407f3f">nodePersistenceConstructorRegister</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a3f14aa5c17f8e32232e690c542b9dfa9">numRegisteredTypes_</a> = 0</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classModel_1_1Node.html" title="The Node class is the foundation element in the model tree in Envision.">Node</a> class is the foundation element in the model tree in Envision. </p>
<p>An application in Envision is a collection of objects of type <a class="el" href="classModel_1_1Node.html" title="The Node class is the foundation element in the model tree in Envision.">Node</a> (and derived) that are managed by a single <a class="el" href="classModel_1_1Model.html" title="The Model class is a management and access entity for a program tree.">Model</a> object. Nodes are combined together in a tree structure. This class defines the minimal interface of each node and implements some service functions.</p>
<p>Each class that derives from <a class="el" href="classModel_1_1Node.html" title="The Node class is the foundation element in the model tree in Envision.">Node</a> must have at least two constructors which need to be registered before that class can be used. This is achieved using the static methods '<a class="el" href="classModel_1_1Node.html#a96dd7615292eeba03fe903f623fb1305" title="Registers the constructors of a class derived from Node.">registerNodeType()</a>', '<a class="el" href="classModel_1_1Node.html#a0ca79f2a20d8993eea0e86ca6088da7c" title="Creates a new node of the specified type.">createNewNode()</a>' and '<a class="el" href="namespaceModel.html#a3ac548bcb7909db2dae98298082bd9f6" title="This is a convenience function that can be used when registering classes derived from Node using regi...">createNodeFromPersistence()</a>'.</p>
<p>Derived classes must implement the '<a class="el" href="classModel_1_1Node.html#a30d34fac51548633d6748b09f47a3d92" title="Saves the current node to a persistent store.">save()</a>' and '<a class="el" href="classModel_1_1Node.html#a20246c48b754e0fceeb7c921f2f1f57b" title="Reloads this node from a persistent store.">load()</a>' methods that specify how the node is stored in a persistent store.</p>
<p>A new class that derives from <a class="el" href="classModel_1_1Node.html" title="The Node class is the foundation element in the model tree in Envision.">Node</a> must define many standard methods and constructors. Many macros have been defined that greatly simplify this task. See 'nodeMacros.h' for more details.</p>
<p>A node in the tree has a revision number. Each time a node is created or loaded from a persistent store this number is reset to 0. Any modification to the node causes the revision to be incremented. This can be then used by visualizations or other plug-ins to track the evolution of node and update it necessary. A node's revision number will also increase when any of its descendants is modified, added or removed.</p>
<p>A node that supports partial loading, should reimplement the '<a class="el" href="classModel_1_1Node.html#ab33abbe1a349349d108142e07bb19db5" title="Fully loads a partially loaded node from the specified persistent store.">loadFully()</a>' method to enable this functionality.</p>
<p>The functionality offered by the <a class="el" href="classModel_1_1Node.html" title="The Node class is the foundation element in the model tree in Envision.">Node</a> class includes:</p>
<ul>
<li>Navigation routines between parents and children.</li>
<li>Navigation routines between different subtrees.</li>
<li>Revision control.</li>
<li>Persistent store interaction.</li>
<li>Meta information. </li>
</ul>
</div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a9eedfb121970934710f1f3c67c26f361"></a><!-- doxytag: member="Model::Node::NodeConstructor" ref="a9eedfb121970934710f1f3c67c26f361" args=")(Node *parent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classModel_1_1Node.html">Node</a>*(* <a class="el" href="classModel_1_1Node.html#a9eedfb121970934710f1f3c67c26f361">Model::Node::NodeConstructor</a>)(<a class="el" href="classModel_1_1Node.html">Node</a> *<a class="el" href="classModel_1_1Node.html#a0027c2328323a4733b3e594958b6998a">parent</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function pointer type is used to register a constructor for nodes. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>The parent node of the newly created node. This may be 'nullptr'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a36d456dafe5835b3f28142507f90cd89"></a><!-- doxytag: member="Model::Node::NodePersistenceConstructor" ref="a36d456dafe5835b3f28142507f90cd89" args=")(Node *parent, PersistentStore &amp;store, bool partialLoadHint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classModel_1_1Node.html">Node</a>*(* <a class="el" href="classModel_1_1Node.html#a36d456dafe5835b3f28142507f90cd89">Model::Node::NodePersistenceConstructor</a>)(<a class="el" href="classModel_1_1Node.html">Node</a> *<a class="el" href="classModel_1_1Node.html#a0027c2328323a4733b3e594958b6998a">parent</a>, <a class="el" href="classModel_1_1PersistentStore.html">PersistentStore</a> &amp;store, bool partialLoadHint)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function pointer type is used to register the constructor for nodes that are being loaded from a persistent store. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>The parent node of the newly created node. This can be NULL to indicate that this node is the root node for the model. Otherwise it should be non-NULL. </td></tr>
    <tr><td class="paramname">id</td><td>The id of the node from the persistent store. </td></tr>
    <tr><td class="paramname">store</td><td>The store that is contains this node and its subtree. This will be used to load the children of the node. </td></tr>
    <tr><td class="paramname">partialLoadHint</td><td>A flag that hints whether this node should be fully or partially loaded. The constructor of the node is allowed to ignore this flag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="af2ff52f8a834ec055dca6867ba794208"></a><!-- doxytag: member="Model::Node::FindSymbolMode" ref="af2ff52f8a834ec055dca6867ba794208" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classModel_1_1Node.html#af2ff52f8a834ec055dca6867ba794208">Model::Node::FindSymbolMode</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="af2ff52f8a834ec055dca6867ba794208a442bce153404d787512d1392ba9000fa"></a><!-- doxytag: member="SEARCH_UP" ref="af2ff52f8a834ec055dca6867ba794208a442bce153404d787512d1392ba9000fa" args="" -->SEARCH_UP</em>&nbsp;</td><td>
<p>Looks for symbols within the specified scope and enclosing scopes. </p>
<p>Depending on the source, symbols in the current scope which come after the source will not be considered. This is the case e.g. with searches for local variable declarations in a method: only variables before the source node should be considered. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af2ff52f8a834ec055dca6867ba794208ad32cc9e783e89ba6ffb83011a55abe97"></a><!-- doxytag: member="SEARCH_DOWN" ref="af2ff52f8a834ec055dca6867ba794208ad32cc9e783e89ba6ffb83011a55abe97" args="" -->SEARCH_DOWN</em>&nbsp;</td><td>
<p>Looks for symbols inside the specified scope or subscopes. </p>
<p>This is used for symbols that are requested in a specific context (typically after a '.') e.g. "list.sort()" </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6026745a457fb0edde390e06c8168391"></a><!-- doxytag: member="Model::Node::Node" ref="a6026745a457fb0edde390e06c8168391" args="(Node *parent=nullptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1Node.html#a6026745a457fb0edde390e06c8168391">Model::Node::Node</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a new node with the specified parent. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>The parent of this node. This may be 'nullptr'.</td></tr>
  </table>
  </dd>
</dl>
<p>If the parent is not null, then the model associated with the parent will also be the model for this node. If the parent is nullptr, then this node will not be associated with a model initially. It can later be added to an existing model. </p>

</div>
</div>
<a class="anchor" id="ab93b813886967b6d93a351c75f31b6e5"></a><!-- doxytag: member="Model::Node::~Node" ref="ab93b813886967b6d93a351c75f31b6e5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1Node.html#ab93b813886967b6d93a351c75f31b6e5">Model::Node::~Node</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aa33e411bb1aa1aabca6d162f66bc481f"></a><!-- doxytag: member="Model::Node::accessLock" ref="aa33e411bb1aa1aabca6d162f66bc481f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1NodeReadWriteLock.html">NodeReadWriteLock</a> * <a class="el" href="classModel_1_1Node.html#aa33e411bb1aa1aabca6d162f66bc481f">Model::Node::accessLock</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the lock used to control access to this node. </p>
<p>If a node should represent a new access unit, this method should be overriden to return a lock associated with the node.</p>
<p>The default implementation just asks for the lock of the parent, or if the parent is NULL for the root lock of the model. </p>

<p>Reimplemented in <a class="el" href="classTestNodes_1_1BinaryNodeAccessUnit.html#ab032a8070a11910b1f789aedefd33514">TestNodes::BinaryNodeAccessUnit</a>.</p>

</div>
</div>
<a class="anchor" id="a72c0d0ffbf6398cc48fd6627ddab6cfe"></a><!-- doxytag: member="Model::Node::addToRevision" ref="a72c0d0ffbf6398cc48fd6627ddab6cfe" args="(int valueToAdd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classModel_1_1Node.html#a72c0d0ffbf6398cc48fd6627ddab6cfe">Model::Node::addToRevision</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>valueToAdd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Increments the revision of this node by the specified amount. </p>

</div>
</div>
<a class="anchor" id="ae6c6fa88579de718cfc16e2a5c22e8e3"></a><!-- doxytag: member="Model::Node::beginModification" ref="ae6c6fa88579de718cfc16e2a5c22e8e3" args="(const QString &amp;text=QString())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classModel_1_1Node.html#ae6c6fa88579de718cfc16e2a5c22e8e3">Model::Node::beginModification</a> </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>text</em> = <code>QString()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Begins a modification session with the current node as a modification target. </p>
<p><em>text</em> is the description that will be associated with this modification.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classModel_1_1Model.html#aeb529525d3f1a3b95f9abfec9aa7487d" title="Begins a modification session.">Model::beginModification()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a94bae646017c4e4cb3214d0ecc26c539"></a><!-- doxytag: member="Model::Node::children" ref="a94bae646017c4e4cb3214d0ecc26c539" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QList&lt; <a class="el" href="classModel_1_1Node.html">Node</a> * &gt; <a class="el" href="classModel_1_1Node.html#a94bae646017c4e4cb3214d0ecc26c539">Model::Node::children</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a list of all child nodes. </p>
<p>Reimplement this method in derived classes that have children. The default implementation returns an empty list. </p>

<p>Reimplemented in <a class="el" href="classModel_1_1ExtendableNode.html#a390e2be2a76f198706326d3362e8d129">Model::ExtendableNode</a>, and <a class="el" href="classModel_1_1List.html#ad90082b4310f9bd1de70b0fa4944fbca">Model::List</a>.</p>

</div>
</div>
<a class="anchor" id="a0ca79f2a20d8993eea0e86ca6088da7c"></a><!-- doxytag: member="Model::Node::createNewNode" ref="a0ca79f2a20d8993eea0e86ca6088da7c" args="(const QString &amp;type, Node *parent=nullptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1Node.html">Node</a> * <a class="el" href="classModel_1_1Node.html#a0ca79f2a20d8993eea0e86ca6088da7c">Model::Node::createNewNode</a> </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new node of the specified type. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of the node to create. This must be a type that has been registered before by calling registerNodeType.</td></tr>
    <tr><td class="paramname">parent</td><td>The parent of the node. This may be 'nullptr'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a12d7cfdf3abf4c1c2bbefc3654678805"></a><!-- doxytag: member="Model::Node::createNewNode" ref="a12d7cfdf3abf4c1c2bbefc3654678805" args="(const QString &amp;type, Node *parent, PersistentStore &amp;store, bool partialLoadHint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1Node.html">Node</a> * <a class="el" href="classModel_1_1Node.html#a0ca79f2a20d8993eea0e86ca6088da7c">Model::Node::createNewNode</a> </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classModel_1_1PersistentStore.html">PersistentStore</a> &amp;&#160;</td>
          <td class="paramname"><em>store</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>partialLoadHint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new node of the specified type by loading it from a persistent store. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of the node to create. This must be a type that has been registered before by calling registerNodeType.</td></tr>
    <tr><td class="paramname">parent</td><td>The parent of the node. This can be NULL if this is the root node.</td></tr>
    <tr><td class="paramname">store</td><td>The persistent store to use to load the subtree of this node.</td></tr>
    <tr><td class="paramname">partialLoadHint</td><td>Whether this node should only be partially loaded. This is only a hint and a node implementation can ignore this flag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acc19699b25363ba3474acf0000da4329"></a><!-- doxytag: member="Model::Node::definesSymbol" ref="acc19699b25363ba3474acf0000da4329" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classModel_1_1Node.html#acc19699b25363ba3474acf0000da4329">Model::Node::definesSymbol</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if this node defines a symbol and false otherwise. </p>
<p>The default implementaion returns false. Reimplement this method and <a class="el" href="classModel_1_1Node.html#ac0238f80b3ad5960919e56e959fb8b36" title="Returns the name of the symbol defined by this node.">symbolName()</a> in derived classes that define symbols. </p>

<p>Reimplemented in <a class="el" href="classOOModel_1_1Method.html#ab8cac3e4ac449ec288b0f172f0072e47">OOModel::Method</a>, <a class="el" href="classOOModel_1_1Class.html#a4094b0470110f96bb51ebd6aae14a851">OOModel::Class</a>, <a class="el" href="classOOModel_1_1Field.html#aa9ccb63bb4787250734621fc97fe02da">OOModel::Field</a>, <a class="el" href="classOOModel_1_1FormalArgument.html#a22f0cbb968a5887378329f36938154fa">OOModel::FormalArgument</a>, <a class="el" href="classOOModel_1_1ForEachStatement.html#ae5321b9cfc76603a8e2abf41530530da">OOModel::ForEachStatement</a>, and <a class="el" href="classOOModel_1_1ExpressionStatement.html#a983a24fd719bb8854bdb68b3f60fca1f">OOModel::ExpressionStatement</a>.</p>

</div>
</div>
<a class="anchor" id="ad54d77f21d23364b560deeca22a6347e"></a><!-- doxytag: member="Model::Node::endModification" ref="ad54d77f21d23364b560deeca22a6347e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classModel_1_1Node.html#ad54d77f21d23364b560deeca22a6347e">Model::Node::endModification</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ends a modification session. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classModel_1_1Model.html#a995413407a52a23bea27ec69266e8074" title="Ends a modification session.">Model::endModification()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9aad10e0ec7b9359f325db5a3c4fbf90"></a><!-- doxytag: member="Model::Node::execute" ref="a9aad10e0ec7b9359f325db5a3c4fbf90" args="(UndoCommand *command)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classModel_1_1Node.html#a9aad10e0ec7b9359f325db5a3c4fbf90">Model::Node::execute</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1UndoCommand.html">UndoCommand</a> *&#160;</td>
          <td class="paramname"><em>command</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Executes the specified command and pushes it on the undo stack. </p>
<p>This method will fail with an exception if the current thread does not hold the lock for this node's access unit.</p>
<p>This method also increments the revision of the node by 1. </p>

</div>
</div>
<a class="anchor" id="a79f332d52ca064cf24683b6efe319249"></a><!-- doxytag: member="Model::Node::findSymbols" ref="a79f332d52ca064cf24683b6efe319249" args="(const QRegExp &amp;symbolExp, Node *source, FindSymbolMode mode, bool exhaustAllScopes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QList&lt; <a class="el" href="classModel_1_1Node.html">Node</a> * &gt; <a class="el" href="classModel_1_1Node.html#a79f332d52ca064cf24683b6efe319249">Model::Node::findSymbols</a> </td>
          <td>(</td>
          <td class="paramtype">const QRegExp &amp;&#160;</td>
          <td class="paramname"><em>symbolExp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html#af2ff52f8a834ec055dca6867ba794208">FindSymbolMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exhaustAllScopes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a list of all nodes which define a symbol with a name matching <em>symbolExp</em> in the scope of this node. </p>
<p>The <em>source</em> <a class="el" href="classModel_1_1Node.html" title="The Node class is the foundation element in the model tree in Envision.">Node</a> specifies what node should be used as a reference when determining what symbols are visible.</p>
<p>The <em>mode</em> specifies what search to perform.</p>
<p>If <em>exhaustAllScopes</em> is false, the search will halt as soon as symbols are found within a scope. This is useful when resolving links and it is important to find the "nearest" symbols that match with respect to scope. If <em>exhaustAllScopes</em> is true, the search will explore all scopes in corresponding to the provided mode. This is useful when <em>symbolExp</em> can match multiple symbols with different names (for example during auto completion list build up).</p>
<p>The default implementation returns a list with only the current node in it, in case the node defines the requested symbol. Otherwise if <em>mode</em> is FindSymbolMode::SEARCH_UP, the implementation of the parent node is called.</p>
<p>Reimplement this method in derived classes to specify fine grained behavior and operation for search modes other than FindSymbolMode::SEARCH_UP </p>

</div>
</div>
<a class="anchor" id="ae14f15bda5e64f3f6e8fe62b6dde75bb"></a><!-- doxytag: member="Model::Node::findSymbols" ref="ae14f15bda5e64f3f6e8fe62b6dde75bb" args="(const QString &amp;symbol, Node *source, FindSymbolMode mode, bool exhaustAllScopes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QList&lt; <a class="el" href="classModel_1_1Node.html">Node</a> * &gt; <a class="el" href="classModel_1_1Node.html#a79f332d52ca064cf24683b6efe319249">Model::Node::findSymbols</a> </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html#af2ff52f8a834ec055dca6867ba794208">FindSymbolMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exhaustAllScopes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This is equivalent to: </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="classModel_1_1Node.html#a79f332d52ca064cf24683b6efe319249" title="Returns a list of all nodes which define a symbol with a name matching symbolExp in the scope of this...">findSymbols</a>(QRegExp(symbol, Qt::CaseSensitive, QRegExp::FixedString), source, mode)
</pre></div> 
</div>
</div>
<a class="anchor" id="a99b6186b6f8f5259dc93ab37be1c1094"></a><!-- doxytag: member="Model::Node::hierarchyTypeIds" ref="a99b6186b6f8f5259dc93ab37be1c1094" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QList&lt; int &gt; <a class="el" href="classModel_1_1Node.html#a99b6186b6f8f5259dc93ab37be1c1094">Model::Node::hierarchyTypeIds</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a list of all ids in the type hierarchy of this node (excluding abstract base classes). </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classModel_1_1Node.html#a1dab7cf9f13060ea1d7c72f979844619" title="Returns an integer id of the type of this Node.">typeId()</a>.</dd></dl>
<p>The most derived id appears at the front of the list.</p>
<p>The default implementation returns a list containing only the id of <a class="el" href="classModel_1_1Node.html" title="The Node class is the foundation element in the model tree in Envision.">Node</a>. </p>

<p>Reimplemented in <a class="el" href="classModel_1_1ExtendableNode.html#a8830492627814a419e07ab97f0cd332e">Model::ExtendableNode</a>, <a class="el" href="classModel_1_1List.html#a310fb2a2b48e7c1f0247a42aca2cc925">Model::List</a>, <a class="el" href="classModel_1_1Text.html#a9247d130419e4b6c1b9ae76fce33f72e">Model::Text</a>, <a class="el" href="classModel_1_1TypedList.html#a945e841700fba50c31bf64eacf433685">Model::TypedList&lt; T &gt;</a>, <a class="el" href="classModel_1_1TypedList.html#a945e841700fba50c31bf64eacf433685">Model::TypedList&lt; StatementItem &gt;</a>, <a class="el" href="classTestNodes_1_1BinaryNode.html#aad536c58f91acb8d08357d9a231e2052">TestNodes::BinaryNode</a>, <a class="el" href="classModel_1_1Reference.html#a5df7762e4e3abd0aac9195cb43e8f5fd">Model::Reference</a>, <a class="el" href="classTestNodes_1_1BinaryNodeAccessUnit.html#a758df9a896c55fe3b2e8cd95c264e1d8">TestNodes::BinaryNodeAccessUnit</a>, <a class="el" href="classTestNodes_1_1BinaryNodePersistenceUnit.html#aeb714f8766b929ebd692e9b3c7e71134">TestNodes::BinaryNodePersistenceUnit</a>, <a class="el" href="classModel_1_1Boolean.html#a4e616690f3e6ae76ad68a912f2425f79">Model::Boolean</a>, <a class="el" href="classModel_1_1Character.html#ac4a2a444a51feb46f81f4ec32c1689b3">Model::Character</a>, <a class="el" href="classModel_1_1Float.html#a4ddaa7e3f6f74be075fb9fdadb003223">Model::Float</a>, <a class="el" href="classModel_1_1Integer.html#ab4399387bf2d583ae60ed24b71084ee8">Model::Integer</a>, <a class="el" href="classModel_1_1TypedList.html#a85781b8d1d3d39c3dd5e815f9dc563aa">Model::TypedList&lt; T &gt;</a>, and <a class="el" href="classModel_1_1TypedList.html#a85781b8d1d3d39c3dd5e815f9dc563aa">Model::TypedList&lt; StatementItem &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a410cafa4e196e8f572d6f24992bfc914"></a><!-- doxytag: member="Model::Node::incrementRevision" ref="a410cafa4e196e8f572d6f24992bfc914" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classModel_1_1Node.html#a410cafa4e196e8f572d6f24992bfc914">Model::Node::incrementRevision</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Increments the revision of this node by 1. </p>

</div>
</div>
<a class="anchor" id="a9fdb27f1c721bd3d89c7881dabd7efc9"></a><!-- doxytag: member="Model::Node::isAncestorOf" ref="a9fdb27f1c721bd3d89c7881dabd7efc9" args="(const Node *other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classModel_1_1Node.html#a9fdb27f1c721bd3d89c7881dabd7efc9">Model::Node::isAncestorOf</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true of this node is an Ancestor of other and false otherwise. </p>

</div>
</div>
<a class="anchor" id="a6893aad2fa24f8d83cd73fc8106f5ac9"></a><!-- doxytag: member="Model::Node::isFullyLoaded" ref="a6893aad2fa24f8d83cd73fc8106f5ac9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classModel_1_1Node.html#a6893aad2fa24f8d83cd73fc8106f5ac9">Model::Node::isFullyLoaded</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if this node is fully loaded and false if it is only partially loaded. </p>
<p>The default implementation always returns true.</p>
<p>Reimplement this method and <a class="el" href="classModel_1_1Node.html#ab33abbe1a349349d108142e07bb19db5" title="Fully loads a partially loaded node from the specified persistent store.">loadFully()</a> in derived classes that support partial loading. </p>

</div>
</div>
<a class="anchor" id="a78e99d1b37afb4ca5575d68391cc0455"></a><!-- doxytag: member="Model::Node::isModifyable" ref="a78e99d1b37afb4ca5575d68391cc0455" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classModel_1_1Node.html#a78e99d1b37afb4ca5575d68391cc0455">Model::Node::isModifyable</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true is the this node can be modified or false otherwise. </p>
<p>A node is modifiable if it is part of an access unit which is currently acquired by a writer thread. This is managed by the '<a class="el" href="classModel_1_1Model.html" title="The Model class is a management and access entity for a program tree.">Model</a>' associated with the node.</p>
<p>If a node does not have an associated model it is always modifiable. </p>

</div>
</div>
<a class="anchor" id="a3acc47bd4c6dcda029cbcc91a12315e1"></a><!-- doxytag: member="Model::Node::isNewPersistenceUnit" ref="a3acc47bd4c6dcda029cbcc91a12315e1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classModel_1_1Node.html#a3acc47bd4c6dcda029cbcc91a12315e1">Model::Node::isNewPersistenceUnit</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if this node should be persisted in a new persistence unit. </p>
<p>This is typically a per class value.</p>
<p>When the user saves the project normally the entire corresponding application tree is saved. To optimize the amount of data written to disk, it is possible to indicate new persistence units. Whenever a node in the application is modified only the persistent unit it belongs to, together with all persistence units of its parents are saved.</p>
<p>For example, to simulate the typical scenario of saving classes in different files, a node which represents a class should return true as the result of this method.</p>
<p>NOTE: The persistence engine will save the ID and last revision of all objects that which are marked as a new persistence unit. Therefore this option should be used with care. Only node types closer to the root are suitable for being new persistence units. Nodes closer to the leafs, such as expressions and text values should not be new persistence units, as this will greatly increase the memory required by the persistence engine. </p>

<p>Reimplemented in <a class="el" href="classTestNodes_1_1BinaryNodePersistenceUnit.html#a2b1bfb71cca07a152e34c8b6480a6d54">TestNodes::BinaryNodePersistenceUnit</a>.</p>

</div>
</div>
<a class="anchor" id="abce3db1f4cf4cf5192694631148aebcb"></a><!-- doxytag: member="Model::Node::isTypeRegistered" ref="abce3db1f4cf4cf5192694631148aebcb" args="(const QString &amp;type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classModel_1_1Node.html#abce3db1f4cf4cf5192694631148aebcb">Model::Node::isTypeRegistered</a> </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if there are already registered constructs for a type with the specified name and false otherwise. </p>

</div>
</div>
<a class="anchor" id="a20246c48b754e0fceeb7c921f2f1f57b"></a><!-- doxytag: member="Model::Node::load" ref="a20246c48b754e0fceeb7c921f2f1f57b" args="(PersistentStore &amp;store)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classModel_1_1Node.html#a20246c48b754e0fceeb7c921f2f1f57b">Model::Node::load</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1PersistentStore.html">PersistentStore</a> &amp;&#160;</td>
          <td class="paramname"><em>store</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reloads this node from a persistent store. </p>
<p>This method is called at any point after this node has been created in order to reinitialize its contents from the persistent store. Any existing subtree should be gracefully detached. This means that subtrees should not be deleted, but simply detached from the current node in a reversible way using commands that can be undone. </p>

<p>Implemented in <a class="el" href="classModel_1_1ExtendableNode.html#ab898f7437b289850580141065d2eb76e">Model::ExtendableNode</a>, <a class="el" href="classModel_1_1Text.html#ae5c67269d8628272d109b629ae1bfddf">Model::Text</a>, <a class="el" href="classModel_1_1List.html#a0db28c563346d89e1fd618c27fb89641">Model::List</a>, <a class="el" href="classOOModel_1_1StorageSpecifier.html#a40a82aad49da8b4c2c5c8a29e14637a5">OOModel::StorageSpecifier</a>, <a class="el" href="classOOModel_1_1Visibility.html#a0572bb0f151a6e78ba11116c71a1154a">OOModel::Visibility</a>, <a class="el" href="classModel_1_1Reference.html#ae95ac5d75656ff8822da3fa8893cee41">Model::Reference</a>, <a class="el" href="classModel_1_1Boolean.html#a3311a99ea61e53062119fb8c957cf6e9">Model::Boolean</a>, <a class="el" href="classModel_1_1Character.html#af21602de2c4a2d32081894d8f8de73e2">Model::Character</a>, <a class="el" href="classModel_1_1Float.html#a48f7ba27d33876028326427e739d15ac">Model::Float</a>, and <a class="el" href="classModel_1_1Integer.html#ad9f708be045766e9664727258e60b351">Model::Integer</a>.</p>

</div>
</div>
<a class="anchor" id="ab33abbe1a349349d108142e07bb19db5"></a><!-- doxytag: member="Model::Node::loadFully" ref="ab33abbe1a349349d108142e07bb19db5" args="(PersistentStore &amp;store)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classModel_1_1Node.html#ab33abbe1a349349d108142e07bb19db5">Model::Node::loadFully</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1PersistentStore.html">PersistentStore</a> &amp;&#160;</td>
          <td class="paramname"><em>store</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fully loads a partially loaded node from the specified persistent store. </p>
<p>The default implementation does nothing. Reimplement this method and <a class="el" href="classModel_1_1Node.html#a6893aad2fa24f8d83cd73fc8106f5ac9" title="Returns true if this node is fully loaded and false if it is only partially loaded.">isFullyLoaded()</a> in derived classes to enable support for partial loading. </p>

<p>Reimplemented in <a class="el" href="classModel_1_1List.html#ad648bbec49c83b08efbca5cde8027991">Model::List</a>.</p>

</div>
</div>
<a class="anchor" id="abb715885b1d1e5cb97aec8ab7888334b"></a><!-- doxytag: member="Model::Node::lowestCommonAncestor" ref="abb715885b1d1e5cb97aec8ab7888334b" args="(Node *other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1Node.html">Node</a> * <a class="el" href="classModel_1_1Node.html#abb715885b1d1e5cb97aec8ab7888334b">Model::Node::lowestCommonAncestor</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the lowest common ancestor of this node and other. </p>

</div>
</div>
<a class="anchor" id="a8eb7d7162522ca5e4000ce4e2c77ab35"></a><!-- doxytag: member="Model::Node::model" ref="a8eb7d7162522ca5e4000ce4e2c77ab35" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1Model.html">Model</a> * <a class="el" href="classModel_1_1Node.html#a8eb7d7162522ca5e4000ce4e2c77ab35">Model::Node::model</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the model managing the tree of the current <a class="el" href="classModel_1_1Node.html" title="The Node class is the foundation element in the model tree in Envision.">Node</a>. </p>
<p>Calling this method during the creation of the root <a class="el" href="classModel_1_1Node.html" title="The Node class is the foundation element in the model tree in Envision.">Node</a> will return a nullptr. </p>

</div>
</div>
<a class="anchor" id="a0027c2328323a4733b3e594958b6998a"></a><!-- doxytag: member="Model::Node::parent" ref="a0027c2328323a4733b3e594958b6998a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1Node.html">Node</a> * <a class="el" href="classModel_1_1Node.html#a0027c2328323a4733b3e594958b6998a">Model::Node::parent</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the parent of this <a class="el" href="classModel_1_1Node.html" title="The Node class is the foundation element in the model tree in Envision.">Node</a> or NULL if this is the root. </p>

</div>
</div>
<a class="anchor" id="a38b8c8cba2f1ec245a6565436b40693b"></a><!-- doxytag: member="Model::Node::persistentUnitNode" ref="a38b8c8cba2f1ec245a6565436b40693b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1Node.html">Node</a> * <a class="el" href="classModel_1_1Node.html#a38b8c8cba2f1ec245a6565436b40693b">Model::Node::persistentUnitNode</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the node that defines the persistence unit for this node. </p>

</div>
</div>
<a class="anchor" id="a96dd7615292eeba03fe903f623fb1305"></a><!-- doxytag: member="Model::Node::registerNodeType" ref="a96dd7615292eeba03fe903f623fb1305" args="(const QString &amp;type, const NodeConstructor constructor, const NodePersistenceConstructor persistenceconstructor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classModel_1_1Node.html#a96dd7615292eeba03fe903f623fb1305">Model::Node::registerNodeType</a> </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classModel_1_1Node.html#a9eedfb121970934710f1f3c67c26f361">NodeConstructor</a>&#160;</td>
          <td class="paramname"><em>constructor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classModel_1_1Node.html#a36d456dafe5835b3f28142507f90cd89">NodePersistenceConstructor</a>&#160;</td>
          <td class="paramname"><em>persistenceconstructor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Registers the constructors of a class derived from <a class="el" href="classModel_1_1Node.html" title="The Node class is the foundation element in the model tree in Envision.">Node</a>. </p>
<p>Each class derived from <a class="el" href="classModel_1_1Node.html" title="The Node class is the foundation element in the model tree in Envision.">Node</a> must be registered before it can be used.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The string name of the class. </td></tr>
    <tr><td class="paramname">constructor</td><td>A function that can construct a new instance of the class at run-time. </td></tr>
    <tr><td class="paramname">persistenceconstructor</td><td>A function that can construct a new instance of the class from a persistent store. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3b55a33f4c27fb4bb2e99b09ce3f6e63"></a><!-- doxytag: member="Model::Node::replaceChild" ref="a3b55a33f4c27fb4bb2e99b09ce3f6e63" args="(Node *child, Node *replacement, bool releaseOldChild=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classModel_1_1Node.html#a3b55a33f4c27fb4bb2e99b09ce3f6e63">Model::Node::replaceChild</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>releaseOldChild</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replaces the child item <em>child</em> with the item <em>replacement</em> and returns true on success. </p>
<p>The default implementation always returns false and is suitable for nodes without children. Reimplement this method if you are implementing a composite node that has replaceable child nodes.</p>
<p>If <em>releaseOldChild</em> is true, the old child will be released from this node and can be used in other nodes. Otherwise the old child will be managed by the current node's Undo Queue and can not be used for other nodes. </p>

<p>Reimplemented in <a class="el" href="classModel_1_1List.html#a3a6be2bdfe40b5753a9f04c729258f60">Model::List</a>, <a class="el" href="classModel_1_1ExtendableNode.html#a08da1f6d5a1be54bd94572b3872fdf65">Model::ExtendableNode</a>, <a class="el" href="classModel_1_1TypedList.html#a3b1dcf310d8012df73fd17523536d2d0">Model::TypedList&lt; T &gt;</a>, <a class="el" href="classModel_1_1TypedList.html#a3b1dcf310d8012df73fd17523536d2d0">Model::TypedList&lt; StatementItem &gt;</a>, <a class="el" href="classModel_1_1TypedList.html#a532c2a8e786c8e869c3bd7059c658051">Model::TypedList&lt; T &gt;</a>, and <a class="el" href="classModel_1_1TypedList.html#a532c2a8e786c8e869c3bd7059c658051">Model::TypedList&lt; StatementItem &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a868e082304e233d32dde632280c99241"></a><!-- doxytag: member="Model::Node::revision" ref="a868e082304e233d32dde632280c99241" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classModel_1_1Node.html#a868e082304e233d32dde632280c99241">Model::Node::revision</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the revision of this node. </p>

</div>
</div>
<a class="anchor" id="a78ce4ee82d2c0ed0b211fa29aec22923"></a><!-- doxytag: member="Model::Node::root" ref="a78ce4ee82d2c0ed0b211fa29aec22923" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1Node.html">Node</a> * <a class="el" href="classModel_1_1Node.html#a78ce4ee82d2c0ed0b211fa29aec22923">Model::Node::root</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the root node of tree where of this node. </p>

</div>
</div>
<a class="anchor" id="a30d34fac51548633d6748b09f47a3d92"></a><!-- doxytag: member="Model::Node::save" ref="a30d34fac51548633d6748b09f47a3d92" args="(PersistentStore &amp;store) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classModel_1_1Node.html#a30d34fac51548633d6748b09f47a3d92">Model::Node::save</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1PersistentStore.html">PersistentStore</a> &amp;&#160;</td>
          <td class="paramname"><em>store</em></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Saves the current node to a persistent store. </p>
<p>This method should contain calls to the store object that persist the subtree of this node.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">store</td><td>The persistent store to use </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classModel_1_1ExtendableNode.html#a90d3a295c8ae9aae93e673c7d478dfaa">Model::ExtendableNode</a>, <a class="el" href="classModel_1_1Text.html#a189b1d4b114a6d49728a15eb7008c1fa">Model::Text</a>, <a class="el" href="classModel_1_1List.html#a97350256a3eabceba34fc45d735c80d3">Model::List</a>, <a class="el" href="classOOModel_1_1StorageSpecifier.html#a34fdc6b1071bcb2b1ccce9bafcc12cba">OOModel::StorageSpecifier</a>, <a class="el" href="classOOModel_1_1Visibility.html#ad7248b10ef2e60cc2b793c7acd304300">OOModel::Visibility</a>, <a class="el" href="classModel_1_1Reference.html#ada45e380e5f2e88a1758ef796556e482">Model::Reference</a>, <a class="el" href="classModel_1_1Boolean.html#a9f36caabf0d409f5d647ea6b68961e57">Model::Boolean</a>, <a class="el" href="classModel_1_1Character.html#ac2dd14fc314eb170d773852b011feed7">Model::Character</a>, <a class="el" href="classModel_1_1Float.html#a0856b9a633846439bfd3ef54c6ffbbee">Model::Float</a>, and <a class="el" href="classModel_1_1Integer.html#a3cadebc62e9d6ca9c944eca13871d809">Model::Integer</a>.</p>

</div>
</div>
<a class="anchor" id="a0662a376982b4cce855e731a0d8134a8"></a><!-- doxytag: member="Model::Node::setParent" ref="a0662a376982b4cce855e731a0d8134a8" args="(Node *parent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classModel_1_1Node.html#a0662a376982b4cce855e731a0d8134a8">Model::Node::setParent</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the parent of this <a class="el" href="classModel_1_1Node.html" title="The Node class is the foundation element in the model tree in Envision.">Node</a>. </p>

</div>
</div>
<a class="anchor" id="ac0238f80b3ad5960919e56e959fb8b36"></a><!-- doxytag: member="Model::Node::symbolName" ref="ac0238f80b3ad5960919e56e959fb8b36" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const QString &amp; <a class="el" href="classModel_1_1Node.html#ac0238f80b3ad5960919e56e959fb8b36">Model::Node::symbolName</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the name of the symbol defined by this node. </p>
<p>The default implementaion returns a null QString value. Reimplement this method and <a class="el" href="classModel_1_1Node.html#acc19699b25363ba3474acf0000da4329" title="Returns true if this node defines a symbol and false otherwise.">definesSymbol()</a> in derived classes that define symbols. </p>

<p>Reimplemented in <a class="el" href="classOOModel_1_1Method.html#a33f2d5c1bb247e5b4859ff347a1cb952">OOModel::Method</a>, <a class="el" href="classOOModel_1_1Class.html#a08abacf22e6a56c025cc4e1dc85241f1">OOModel::Class</a>, <a class="el" href="classOOModel_1_1Field.html#a8099408698a94e3c89f2c46ccd6b5cf7">OOModel::Field</a>, <a class="el" href="classOOModel_1_1FormalArgument.html#a94b5a337cd8a973b47bd6d0f332bbf7f">OOModel::FormalArgument</a>, <a class="el" href="classOOModel_1_1Project.html#a7c88020c237b1c6a98507dab6c4beef4">OOModel::Project</a>, <a class="el" href="classOOModel_1_1Module.html#a433bb2a3b1d061029cf2c0f1dec935ee">OOModel::Module</a>, <a class="el" href="classOOModel_1_1FormalTypeArgument.html#ac09cfe34b2fd012a3a52dbdc598e8f8c">OOModel::FormalTypeArgument</a>, <a class="el" href="classOOModel_1_1FormalResult.html#a0e1b39a31aeab3752204d43a06bc5a5c">OOModel::FormalResult</a>, <a class="el" href="classOOModel_1_1ForEachStatement.html#a266f42823c614c18f7c89c8c7c1be9f8">OOModel::ForEachStatement</a>, and <a class="el" href="classOOModel_1_1ExpressionStatement.html#a5e2e3e5808867e893a938c210ed27c4f">OOModel::ExpressionStatement</a>.</p>

</div>
</div>
<a class="anchor" id="a1dab7cf9f13060ea1d7c72f979844619"></a><!-- doxytag: member="Model::Node::typeId" ref="a1dab7cf9f13060ea1d7c72f979844619" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classModel_1_1Node.html#a1dab7cf9f13060ea1d7c72f979844619">Model::Node::typeId</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an integer id of the type of this <a class="el" href="classModel_1_1Node.html" title="The Node class is the foundation element in the model tree in Envision.">Node</a>. </p>
<p>When a new node class is registered it receives a unique id. This id can be used later to quickly recognize objects of a specific type. </p>

<p>Reimplemented in <a class="el" href="classModel_1_1ExtendableNode.html#abf6ee053d976820435be009dbcd237f8">Model::ExtendableNode</a>, <a class="el" href="classModel_1_1List.html#aa429554ce28ef8a3e5cd319417c2e7db">Model::List</a>, <a class="el" href="classModel_1_1Text.html#a755ff9466e00a3250c37d524b8203a01">Model::Text</a>, <a class="el" href="classModel_1_1TypedList.html#a69d3e8d4c2d22e99f8ee823657061c54">Model::TypedList&lt; T &gt;</a>, <a class="el" href="classModel_1_1TypedList.html#a69d3e8d4c2d22e99f8ee823657061c54">Model::TypedList&lt; StatementItem &gt;</a>, <a class="el" href="classTestNodes_1_1BinaryNode.html#acac8023bff78df68d4d45063a8d72e34">TestNodes::BinaryNode</a>, <a class="el" href="classModel_1_1Reference.html#a9e0114bda8878c6d650a9b0060da9fca">Model::Reference</a>, <a class="el" href="classTestNodes_1_1BinaryNodeAccessUnit.html#a865f8c7033230b3f1d2e604eb6bb9026">TestNodes::BinaryNodeAccessUnit</a>, <a class="el" href="classTestNodes_1_1BinaryNodePersistenceUnit.html#adea7aa8a80f5e26565665459323c6226">TestNodes::BinaryNodePersistenceUnit</a>, <a class="el" href="classModel_1_1Boolean.html#a7eac2edefb8deedef9527ce7d0afbf9d">Model::Boolean</a>, <a class="el" href="classModel_1_1Character.html#af93c34f450f9c697bc8cd9da2f36c432">Model::Character</a>, <a class="el" href="classModel_1_1Float.html#ae2ef8666860bcd20d3ff1da47f7efaf0">Model::Float</a>, <a class="el" href="classModel_1_1Integer.html#a7cdbf7900f98f645545d8e2a4fe6085a">Model::Integer</a>, <a class="el" href="classModel_1_1TypedList.html#a5a348aa67eedc738501d87ce47dcb730">Model::TypedList&lt; T &gt;</a>, and <a class="el" href="classModel_1_1TypedList.html#a5a348aa67eedc738501d87ce47dcb730">Model::TypedList&lt; StatementItem &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ab01db2467f812532d1c3a441eeae22ea"></a><!-- doxytag: member="Model::Node::typeIdStatic" ref="ab01db2467f812532d1c3a441eeae22ea" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classModel_1_1Node.html#ab01db2467f812532d1c3a441eeae22ea">Model::Node::typeIdStatic</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classModel_1_1ExtendableNode.html#a2384a6458357fd2f198d6e84dbb5ee5d">Model::ExtendableNode</a>, <a class="el" href="classModel_1_1List.html#a4585ddf7782392169c16c3bb418bd852">Model::List</a>, <a class="el" href="classModel_1_1Text.html#a06e10b29a93de74b8e0526e021c8ae8c">Model::Text</a>, <a class="el" href="classModel_1_1TypedList.html#ae0854f83d3aa24f1a05bcfff980384f1">Model::TypedList&lt; T &gt;</a>, <a class="el" href="classModel_1_1TypedList.html#ae0854f83d3aa24f1a05bcfff980384f1">Model::TypedList&lt; StatementItem &gt;</a>, <a class="el" href="classTestNodes_1_1BinaryNode.html#a399df5fb07c9d98bf691bd8fc6cf3857">TestNodes::BinaryNode</a>, <a class="el" href="classModel_1_1Reference.html#aef23e5f2913bd8f2786ef4a021a88ebb">Model::Reference</a>, <a class="el" href="classTestNodes_1_1BinaryNodeAccessUnit.html#a606d7a2fd24f31f7e6c2ecbd8139153e">TestNodes::BinaryNodeAccessUnit</a>, <a class="el" href="classTestNodes_1_1BinaryNodePersistenceUnit.html#af53ca18d57612ec15300d10dfa2f89ef">TestNodes::BinaryNodePersistenceUnit</a>, <a class="el" href="classModel_1_1Boolean.html#ae7316b7332abd1f74f003a12882dfe7d">Model::Boolean</a>, <a class="el" href="classModel_1_1Character.html#aa14fbeac3ea30ab559fbfc6aef85985c">Model::Character</a>, <a class="el" href="classModel_1_1Float.html#a24dd27a676129364085ef8872e17e2a9">Model::Float</a>, <a class="el" href="classModel_1_1Integer.html#a5d3c85e40dcbe4bcb995dd220f7c2595">Model::Integer</a>, <a class="el" href="classModel_1_1TypedList.html#acbff59451a3cf7f40d928a5e80fdecb7">Model::TypedList&lt; T &gt;</a>, and <a class="el" href="classModel_1_1TypedList.html#acbff59451a3cf7f40d928a5e80fdecb7">Model::TypedList&lt; StatementItem &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a032a9d874557533b1c9c5295f6a4b11d"></a><!-- doxytag: member="Model::Node::typeName" ref="a032a9d874557533b1c9c5295f6a4b11d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const QString &amp; <a class="el" href="classModel_1_1Node.html#a032a9d874557533b1c9c5295f6a4b11d">Model::Node::typeName</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the name of the type of this <a class="el" href="classModel_1_1Node.html" title="The Node class is the foundation element in the model tree in Envision.">Node</a>. </p>
<p>This is typically a string identical to the class name.</p>
<p>This value is used when persisting the node. </p>

<p>Reimplemented in <a class="el" href="classModel_1_1ExtendableNode.html#a470d4736f5f452b7a82503f03925b550">Model::ExtendableNode</a>, <a class="el" href="classModel_1_1List.html#ab2202c90a6d1f1a43867d56c88b262eb">Model::List</a>, <a class="el" href="classModel_1_1Text.html#abcc08e5cf83a1607f4d1e03f66e3215c">Model::Text</a>, <a class="el" href="classModel_1_1TypedList.html#a5779b92a0a4b60ee81de96c6c806d4f1">Model::TypedList&lt; T &gt;</a>, <a class="el" href="classModel_1_1TypedList.html#a5779b92a0a4b60ee81de96c6c806d4f1">Model::TypedList&lt; StatementItem &gt;</a>, <a class="el" href="classTestNodes_1_1BinaryNode.html#a64b91d9e0719e3b42c37ee6d17085e06">TestNodes::BinaryNode</a>, <a class="el" href="classModel_1_1Reference.html#a91dc51c54ec2cf8549f83c82c375768c">Model::Reference</a>, <a class="el" href="classTestNodes_1_1BinaryNodeAccessUnit.html#a7fb2465fbb207a329f8890c113f5a10f">TestNodes::BinaryNodeAccessUnit</a>, <a class="el" href="classTestNodes_1_1BinaryNodePersistenceUnit.html#aa1f1779edfd403bc821ea1fb3a52200a">TestNodes::BinaryNodePersistenceUnit</a>, <a class="el" href="classModel_1_1Boolean.html#ab8c99802258c2cf634754d144006a9ac">Model::Boolean</a>, <a class="el" href="classModel_1_1Character.html#a2ce1329f757ada5ba5cab101eea9e3f1">Model::Character</a>, <a class="el" href="classModel_1_1Float.html#af59295616c737167a57c4af4e7bc253c">Model::Float</a>, <a class="el" href="classModel_1_1Integer.html#aec1185d2b3826d886490f750f9a0f63a">Model::Integer</a>, <a class="el" href="classModel_1_1TypedList.html#a7257ab928f8c9ddb5344038c611cb121">Model::TypedList&lt; T &gt;</a>, and <a class="el" href="classModel_1_1TypedList.html#a7257ab928f8c9ddb5344038c611cb121">Model::TypedList&lt; StatementItem &gt;</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="aedd2b252f73e3ede9117bb92e6dfd516"></a><!-- doxytag: member="Model::Node::fullyLoaded" ref="aedd2b252f73e3ede9117bb92e6dfd516" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classModel_1_1Node.html#aedd2b252f73e3ede9117bb92e6dfd516">Model::Node::fullyLoaded</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This flag indicates if the current node is fullyLoaded. </p>
<p>Derived classes which support this functionality should take care to properly initialize and modify this value whener the state of the object changes. </p>

</div>
</div>
<a class="anchor" id="a3e997f8eda29ad3b42d8ac9773afb194"></a><!-- doxytag: member="Model::Node::nodeConstructorRegister" ref="a3e997f8eda29ad3b42d8ac9773afb194" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QMap&lt; QString, <a class="el" href="classModel_1_1Node.html#a9eedfb121970934710f1f3c67c26f361">Node::NodeConstructor</a> &gt; <a class="el" href="classModel_1_1Node.html#a3e997f8eda29ad3b42d8ac9773afb194">Model::Node::nodeConstructorRegister</a><code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abc6b7cb926ca500a5ac3102409407f3f"></a><!-- doxytag: member="Model::Node::nodePersistenceConstructorRegister" ref="abc6b7cb926ca500a5ac3102409407f3f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QMap&lt; QString, <a class="el" href="classModel_1_1Node.html#a36d456dafe5835b3f28142507f90cd89">Node::NodePersistenceConstructor</a> &gt; <a class="el" href="classModel_1_1Node.html#abc6b7cb926ca500a5ac3102409407f3f">Model::Node::nodePersistenceConstructorRegister</a><code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3f14aa5c17f8e32232e690c542b9dfa9"></a><!-- doxytag: member="Model::Node::numRegisteredTypes_" ref="a3f14aa5c17f8e32232e690c542b9dfa9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classModel_1_1Node.html#a3f14aa5c17f8e32232e690c542b9dfa9">Model::Node::numRegisteredTypes_</a> = 0<code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad3a6f51536abb137ede5c427725222d3"></a><!-- doxytag: member="Model::Node::parent_" ref="ad3a6f51536abb137ede5c427725222d3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1Node.html">Node</a>* <a class="el" href="classModel_1_1Node.html#ad3a6f51536abb137ede5c427725222d3">Model::Node::parent_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7cec2acbdfb8620d4901ada5600faacd"></a><!-- doxytag: member="Model::Node::revision_" ref="a7cec2acbdfb8620d4901ada5600faacd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classModel_1_1Node.html#a7cec2acbdfb8620d4901ada5600faacd">Model::Node::revision_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
